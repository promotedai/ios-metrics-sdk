import Foundation

/** Sequence of ancestor IDs. */
protocol IDSequence: AnyObject {

  /// State of ID in producer, which will be used as the
  /// ancestor ID in logged events.
  var currentValue: String? { get set }

  /// Current or pending ID, which can be used to read what
  /// the *next* autogenerated ID for `currentValue` will
  /// be.
  var currentOrPendingValue: String? { get }

  var maximumHistorySize: Int? { get set }

  var history: [String]? { get }
}

/**
 Manages values for ancestor ID sequences.

 Allows clients to read pending ancestor IDs before starting
 a session and keep those IDs consistent when the session
 does start.

 Clients can also assign custom values to the ID.
 */
final class IDProducer: IDSequence {

  typealias Producer = () -> String

  private let initialValueProducer: Producer
  private let nextValueProducer: Producer

  /// State of ID in producer, which will be used as the
  /// ancestor ID in logged events.
  /// If `advance()` has never been called, and this
  /// hasn't been set to an external value, returns `nil`.
  /// Set this value to assign an external ID for use as
  /// this ancestor ID. The external ID you assign will
  /// remain until either you set a new external value,
  /// or you call `advance()` on this producer.
  /// You can also set this value to `nil` to clear this ID
  /// on subsequent logged events.
  var currentValue: String? {
    get { internalCurrentValue }
    set {
      internalCurrentValue = newValue
      currentOrPendingValue = newValue
    }
  }
  private var internalCurrentValue: String? {
    willSet {
      if let historyValue = internalCurrentValue {
        historyQueue?.pushBack(historyValue)
      }
    }
  }

  /// Current or pending ID, which can be used to read what
  /// the *next* autogenerated ID for `currentValue` will
  /// be.
  /// - If `advance()` has never been called, returns the
  ///   initial value. Use this to read the pending initial
  ///   ID before the corresponding ancestor event has been
  ///   logged.
  /// - Otherwise, returns `currentValue`.
  private(set) lazy var currentOrPendingValue: String? =
    initialValueProducer()

  private var historyQueue: Deque<String>?

  var maximumHistorySize: Int? {
    get { historyQueue?.maximumSize }
    set {
      guard let newValue = newValue, newValue > 0 else {
        historyQueue = nil
        return
      }
      if historyQueue == nil {
        historyQueue = Deque<String>(maximumSize: newValue)
        return
      }
      historyQueue?.maximumSize = newValue
    }
  }

  var history: [String]? { historyQueue?.values }

  /// Uses given producer in all cases.
  convenience init(producer: @escaping Producer) {
    self.init(initialValueProducer: producer,
              nextValueProducer: producer)
  }

  /// Uses producers as follows:
  /// - Parameters:
  ///   - initialValueProducer: Used when:
  ///     1. Reading `currentOrPendingValue` for the first
  ///        time, or
  ///     2. Initializing `currentValue` on the first call
  ///        to `advance()`, or
  ///     3. Re-initializing after a call to `reset()`.
  ///   - nextValueProducer: Used when `advance()` is
  ///     called.
  init(initialValueProducer: @escaping Producer,
       nextValueProducer: @escaping Producer) {
    self.initialValueProducer = initialValueProducer
    self.nextValueProducer = nextValueProducer
    self.internalCurrentValue = nil
    self.historyQueue = nil
  }

  @discardableResult func advance() -> String {
    if internalCurrentValue == nil {
      internalCurrentValue = currentOrPendingValue
      return currentValue!
    }
    internalCurrentValue = nextValueProducer()
    currentOrPendingValue = internalCurrentValue
    return internalCurrentValue!
  }

  func reset() {
    internalCurrentValue = nil
    historyQueue?.removeAll()
    currentOrPendingValue = initialValueProducer()
  }
}
