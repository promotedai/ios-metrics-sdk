import Foundation

/**
 Manages values for ancestor ID sequences.

 Allows clients to read pending ancestor IDs before starting
 a session and keep those IDs consistent when the session
 does start.

 Clients can also assign custom values to the ID.
 */
final class IDProducer {

  typealias Producer = () -> String

  private let initialValueProducer: Producer
  private let nextValueProducer: Producer
  private var valueHasBeenSet: Bool
  private lazy var initialValue: String = initialValueProducer()

  /// State of ID in producer, which will be used as the
  /// ancestor ID in logged events.
  /// If `nextValue()` has never been called, and this
  /// hasn't been set to an external value, returns `nil`.
  /// Set this value to assign an external ID for use as
  /// this ancestor ID.
  /// You can also set this value to `nil` to clear this ID
  /// on subsequent logged events.
  var currentValue: String? {
    didSet { valueHasBeenSet = true }
  }

  /// Current or pending ID, which can be used to read what
  /// the *next* autogenerated ID for `currentValue` will
  /// be.
  /// - If `nextValue()` has never been called, returns the
  ///   initial value. Use this to read the pending initial
  ///   ID before the corresponding ancestor event has been
  ///   logged.
  /// - Otherwise, returns `currentValue`.
  var currentOrPendingValue: String? {
    valueHasBeenSet ? currentValue : initialValue
  }

  /// Uses given producer in all cases.
  convenience init(producer: @escaping Producer) {
    self.init(initialValueProducer: producer,
              nextValueProducer: producer)
  }

  /// Uses producers as follows:
  /// - Parameters:
  ///   - initialValueProducer: Used when:
  ///     1. Reading `currentOrPendingValue` for the first
  ///        time, or
  ///     2. Initializing `currentValue` on the first call
  ///        to `nextValue()`, or
  ///     3. Re-initializing after a call to `reset()`.
  ///   - nextValueProducer: Used when `nextValue()` is
  ///     called.
  init(initialValueProducer: @escaping Producer,
       nextValueProducer: @escaping Producer) {
    self.initialValueProducer = initialValueProducer
    self.nextValueProducer = nextValueProducer
    self.valueHasBeenSet = false
    self.currentValue = nil
  }

  @discardableResult func nextValue() -> String {
    if !valueHasBeenSet {
      valueHasBeenSet = true
      currentValue = initialValue
      return currentValue!
    }
    currentValue = nextValueProducer()
    return currentValue!
  }

  func reset() {
    valueHasBeenSet = false
    currentValue = nil
    initialValue = initialValueProducer()
  }
}
