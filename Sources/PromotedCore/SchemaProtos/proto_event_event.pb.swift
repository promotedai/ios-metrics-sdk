// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/event/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The arm (experiment's group) when the Cohort is for an experiment.
/// Next ID = 6.
public enum Event_CohortArm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownGroup // = 0
  case control // = 1
  case treatment // = 2

  /// These are generic arms (groups) that can be used when there are multiple treatments.
  case treatment1 // = 3
  case treatment2 // = 4
  case treatment3 // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownGroup
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownGroup
    case 1: self = .control
    case 2: self = .treatment
    case 3: self = .treatment1
    case 4: self = .treatment2
    case 5: self = .treatment3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownGroup: return 0
    case .control: return 1
    case .treatment: return 2
    case .treatment1: return 3
    case .treatment2: return 4
    case .treatment3: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_CohortArm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_CohortArm] = [
    .unknownGroup,
    .control,
    .treatment,
    .treatment1,
    .treatment2,
    .treatment3,
  ]
}

#endif  // swift(>=4.2)

/// Next ID = 4.
public enum Event_DeviceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownDeviceType // = 0
  case desktop // = 1
  case mobile // = 2
  case tablet // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownDeviceType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDeviceType
    case 1: self = .desktop
    case 2: self = .mobile
    case 3: self = .tablet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownDeviceType: return 0
    case .desktop: return 1
    case .mobile: return 2
    case .tablet: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_DeviceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_DeviceType] = [
    .unknownDeviceType,
    .desktop,
    .mobile,
    .tablet,
  ]
}

#endif  // swift(>=4.2)

/// Contextual information about where impression was served.
/// Allows backends to infer expected behavior about
/// corresponding content.
/// Next ID = 3.
public enum Event_ImpressionSourceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownImpressionSourceType // = 0

  /// Content was served by Promoted Delivery API.
  case delivery // = 1

  /// Content was not served by Promoted Delivery API.
  case clientBackend // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownImpressionSourceType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownImpressionSourceType
    case 1: self = .delivery
    case 2: self = .clientBackend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownImpressionSourceType: return 0
    case .delivery: return 1
    case .clientBackend: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_ImpressionSourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_ImpressionSourceType] = [
    .unknownImpressionSourceType,
    .delivery,
    .clientBackend,
  ]
}

#endif  // swift(>=4.2)

/// The action that user wants to perform.
///
/// Next ID = 16.
public enum Event_ActionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownActionType // = 0

  /// Action that doesn't correspond to any of the below.
  case customActionType // = 1

  /// Navigating to details about content.
  case navigate // = 2

  /// Adding an item to shopping cart.
  case addToCart // = 4

  /// Remove an item from shopping cart.
  case removeFromCart // = 10

  /// Going to checkout.
  case checkout // = 8

  /// Purchasing an item.
  case purchase // = 3

  /// Sharing content.
  case share // = 5

  /// Liking content.
  case like // = 6

  /// Un-liking content.
  case unlike // = 9

  /// Commenting on content.
  case comment // = 7

  /// Making an offer on content.
  case makeOffer // = 11

  /// Asking a question about content.
  case askQuestion // = 12

  /// Answering a question about content.
  case answerQuestion // = 13

  /// Complete sign-in.
  /// No content_id needed.  If set, set it to the Content's ID (not User).
  case completeSignIn // = 14

  /// Complete sign-up.
  /// No content_id needed.  If set, set it to the Content's ID (not User).
  case completeSignUp // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownActionType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownActionType
    case 1: self = .customActionType
    case 2: self = .navigate
    case 3: self = .purchase
    case 4: self = .addToCart
    case 5: self = .share
    case 6: self = .like
    case 7: self = .comment
    case 8: self = .checkout
    case 9: self = .unlike
    case 10: self = .removeFromCart
    case 11: self = .makeOffer
    case 12: self = .askQuestion
    case 13: self = .answerQuestion
    case 14: self = .completeSignIn
    case 15: self = .completeSignUp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownActionType: return 0
    case .customActionType: return 1
    case .navigate: return 2
    case .purchase: return 3
    case .addToCart: return 4
    case .share: return 5
    case .like: return 6
    case .comment: return 7
    case .checkout: return 8
    case .unlike: return 9
    case .removeFromCart: return 10
    case .makeOffer: return 11
    case .askQuestion: return 12
    case .answerQuestion: return 13
    case .completeSignIn: return 14
    case .completeSignUp: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_ActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_ActionType] = [
    .unknownActionType,
    .customActionType,
    .navigate,
    .addToCart,
    .removeFromCart,
    .checkout,
    .purchase,
    .share,
    .like,
    .unlike,
    .comment,
    .makeOffer,
    .askQuestion,
    .answerQuestion,
    .completeSignIn,
    .completeSignUp,
  ]
}

#endif  // swift(>=4.2)

/// This structure is used to help deduplicate identifiers that live in many
/// event types.
/// Next ID = 9.
public struct Event_JoinedIdentifiers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformID: UInt64 = 0

  public var userID: String = String()

  public var logUserID: String = String()

  public var sessionID: String = String()

  public var viewID: String = String()

  public var requestID: String = String()

  public var insertionID: String = String()

  public var impressionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to store user properties.  E.g. purchasedContentIds.
/// Clients can update each User multiple times by logging the User with the same
/// user_id.  Unset fields will not be updated. Repeated fields will act like a
/// merge if the item has a key.  Otherwise, it'll act like an append.
/// Next ID = 7.
public struct Event_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _clientInfo ?? Common_ClientInfo()}
    set {_clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return self._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {self._clientInfo = nil}

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _clientInfo: Common_ClientInfo? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// For linking users to cohorts.
/// Next ID = 11.
public struct Event_CohortMembership {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _clientInfo ?? Common_ClientInfo()}
    set {_clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return self._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {self._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var membershipID: String = String()

  /// Optional.  This field refers to the cohort (currently stored as an enum).
  public var cohortID: String = String()

  /// Optional.
  public var arm: Event_CohortArm = .unknownGroup

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _clientInfo: Common_ClientInfo? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// Locale for session
/// Next ID = 3.
public struct Event_Locale {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CodeReview - Which ISO code is this?  ISO 639-1? 2? 3?
  /// "en", "zh_Hant", "fr"
  public var languageCode: String = String()

  /// CodeReview - Which ISO code?  ISO 3166-1?
  /// "US", "CA", "FR"
  public var regionCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Rectangle size in pixels
/// Next ID = 3.
public struct Event_Size {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: UInt32 = 0

  public var height: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device screen
/// Next ID = 3.
public struct Event_Screen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Android: DisplayMetrics.widthPixels/heightPixels
  /// iOS: UIScreen.nativeBounds.width/height
  public var size: Event_Size {
    get {return _size ?? Event_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  /// Natural scale factor.
  /// Android: DisplayMetrics.density
  /// iOS: UIScreen.scale
  public var scale: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _size: Event_Size? = nil
}

/// A sub-message containing Device info.
/// Next ID = 8.
public struct Event_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceType: Event_DeviceType = .unknownDeviceType

  /// Android: android.os.Build.BRAND
  ///          (eg. "google", "verizon", "tmobile", "Samsung")
  /// iOS: "Apple"
  public var brand: String = String()

  /// Android: android.os.Build.MANUFACTURER
  ///          (eg. "HTC", "Motorola", "HUAWEI")
  /// iOS: "Apple"
  public var manufacturer: String = String()

  /// Android: android.os.Build.MODEL
  ///          (eg. "GT-S5830L", "MB860")
  /// iOS: "iPhoneXX,YY" or "iPadXX,YY"
  public var identifier: String = String()

  /// Android: android.os.Build.VERSION.RELEASE
  /// iOS: "14.4.1"
  public var osVersion: String = String()

  /// Deprecated.
  public var locale: Event_Locale {
    get {return _locale ?? Event_Locale()}
    set {_locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return self._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {self._locale = nil}

  public var screen: Event_Screen {
    get {return _screen ?? Event_Screen()}
    set {_screen = newValue}
  }
  /// Returns true if `screen` has been explicitly set.
  public var hasScreen: Bool {return self._screen != nil}
  /// Clears the value of `screen`. Subsequent reads from it will return its default value.
  public mutating func clearScreen() {self._screen = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _locale: Event_Locale? = nil
  fileprivate var _screen: Event_Screen? = nil
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// A newer alternative to user agent strings.
public struct Event_ClientHints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isMobile: Bool = false

  public var brand: [Event_ClientHintBrand] = []

  public var architecture: String = String()

  public var model: String = String()

  public var platform: String = String()

  public var platformVersion: String = String()

  public var uaFullVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// a part of ClientHints.
public struct Event_ClientHintBrand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var brand: String = String()

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A sub-message containing Browser info.
/// Next ID = 4.
public struct Event_Browser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAgent: String = String()

  public var viewportSize: Event_Size {
    get {return _viewportSize ?? Event_Size()}
    set {_viewportSize = newValue}
  }
  /// Returns true if `viewportSize` has been explicitly set.
  public var hasViewportSize: Bool {return self._viewportSize != nil}
  /// Clears the value of `viewportSize`. Subsequent reads from it will return its default value.
  public mutating func clearViewportSize() {self._viewportSize = nil}

  public var clientHints: Event_ClientHints {
    get {return _clientHints ?? Event_ClientHints()}
    set {_clientHints = newValue}
  }
  /// Returns true if `clientHints` has been explicitly set.
  public var hasClientHints: Bool {return self._clientHints != nil}
  /// Clears the value of `clientHints`. Subsequent reads from it will return its default value.
  public mutating func clearClientHints() {self._clientHints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _viewportSize: Event_Size? = nil
  fileprivate var _clientHints: Event_ClientHints? = nil
}

/// Next ID = 3.
public struct Event_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [-90, 90]
  public var latitude: Double = 0

  /// [-180, 180]
  public var longitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Submessage on View for Web page visits.
/// Next ID = 5.
public struct Event_WebPageView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  This is the url for the page.
  public var url: String = String()

  /// Optional.
  public var browser: Event_Browser {
    get {return _browser ?? Event_Browser()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  /// Optional.  Can be a full referrer string.  Could be just the UTM.
  public var referrer: String = String()

  public var documentSize: Event_Size {
    get {return _documentSize ?? Event_Size()}
    set {_documentSize = newValue}
  }
  /// Returns true if `documentSize` has been explicitly set.
  public var hasDocumentSize: Bool {return self._documentSize != nil}
  /// Clears the value of `documentSize`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentSize() {self._documentSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _browser: Event_Browser? = nil
  fileprivate var _documentSize: Event_Size? = nil
}

/// Submessage on View for screen views.
/// Next ID = 2.
public struct Event_AppScreenView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A view of a single page/screen (e.g. feed, search results, etc).
/// Next ID = 17.
public struct Event_View {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional.  The name of the view.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.
  public var useCase: Delivery_UseCase {
    get {return _storage._useCase}
    set {_uniqueStorage()._useCase = newValue}
  }

  /// Optional.
  public var searchQuery: String {
    get {return _storage._searchQuery}
    set {_uniqueStorage()._searchQuery = newValue}
  }

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  /// Optional.
  public var device: Event_Device {
    get {return _storage._device ?? Event_Device()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {_uniqueStorage()._device = nil}

  public var locale: Event_Locale {
    get {return _storage._locale ?? Event_Locale()}
    set {_uniqueStorage()._locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return _storage._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {_uniqueStorage()._locale = nil}

  /// If a specific view is set (`web_page_view` and `app_screen_view`),
  /// clients do not need to set it directly.  If those fields and `view_type`
  /// have conflicting values, the specific view field is used.
  public var viewType: Event_View.ViewType {
    get {return _storage._viewType}
    set {_uniqueStorage()._viewType = newValue}
  }

  public var uiType: OneOf_UiType? {
    get {return _storage._uiType}
    set {_uniqueStorage()._uiType = newValue}
  }

  public var webPageView: Event_WebPageView {
    get {
      if case .webPageView(let v)? = _storage._uiType {return v}
      return Event_WebPageView()
    }
    set {_uniqueStorage()._uiType = .webPageView(newValue)}
  }

  public var appScreenView: Event_AppScreenView {
    get {
      if case .appScreenView(let v)? = _storage._uiType {return v}
      return Event_AppScreenView()
    }
    set {_uniqueStorage()._uiType = .appScreenView(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_UiType: Equatable {
    case webPageView(Event_WebPageView)
    case appScreenView(Event_AppScreenView)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_View.OneOf_UiType, rhs: Event_View.OneOf_UiType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.webPageView, .webPageView): return {
        guard case .webPageView(let l) = lhs, case .webPageView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appScreenView, .appScreenView): return {
        guard case .appScreenView(let l) = lhs, case .appScreenView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ViewType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownViewType // = 0
    case webPage // = 1
    case appScreen // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownViewType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownViewType
      case 1: self = .webPage
      case 2: self = .appScreen
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownViewType: return 0
      case .webPage: return 1
      case .appScreen: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Event_View.ViewType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_View.ViewType] = [
    .unknownViewType,
    .webPage,
    .appScreen,
  ]
}

#endif  // swift(>=4.2)

/// When an Insertion (instance of Content) is shown to a user.
/// Impressions are immutable.
/// Next ID = 14.
public struct Event_Impression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _clientInfo ?? Common_ClientInfo()}
    set {_clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return self._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {self._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var impressionID: String = String()

  /// Optional.
  public var insertionID: String = String()

  /// Optional.
  public var requestID: String = String()

  /// Optional.
  public var viewID: String = String()

  /// Optional.
  public var sessionID: String = String()

  /// Optional. content_id is used as a hint when insertion_id is not set.
  /// For more accurate results, set insertion_id.
  public var contentID: String = String()

  /// Optional.
  public var sourceType: Event_ImpressionSourceType = .unknownImpressionSourceType

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _clientInfo: Common_ClientInfo? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// Next ID = 2.
public struct Event_NavigateAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  The next URL.
  public var targetURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Actions are user actions.  Example: Click.
/// Actions are immutable.
/// Next ID = 22.
public struct Event_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var actionID: String {
    get {return _storage._actionID}
    set {_uniqueStorage()._actionID = newValue}
  }

  /// Optional.
  public var impressionID: String {
    get {return _storage._impressionID}
    set {_uniqueStorage()._impressionID = newValue}
  }

  /// Optional.
  public var insertionID: String {
    get {return _storage._insertionID}
    set {_uniqueStorage()._insertionID = newValue}
  }

  /// Optional.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Optional.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional. content_id is used as a hint when impression_id is not set.
  /// For more accurate results, set impression_id if available.
  public var contentID: String {
    get {return _storage._contentID}
    set {_uniqueStorage()._contentID = newValue}
  }

  /// Optional.  Custom name of the action that the user performed.
  /// E.g. "Product clicked".  Do not stick parameters or pii in this name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.  The action that the user wants to perform.
  public var actionType: Event_ActionType {
    get {return _storage._actionType}
    set {_uniqueStorage()._actionType = newValue}
  }

  /// Optional.
  public var customActionType: String {
    get {return _storage._customActionType}
    set {_uniqueStorage()._customActionType = newValue}
  }

  public var elementID: String {
    get {return _storage._elementID}
    set {_uniqueStorage()._elementID = newValue}
  }

  public var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var navigateAction: Event_NavigateAction {
    get {
      if case .navigateAction(let v)? = _storage._action {return v}
      return Event_NavigateAction()
    }
    set {_uniqueStorage()._action = .navigateAction(newValue)}
  }

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    case navigateAction(Event_NavigateAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_Action.OneOf_Action, rhs: Event_Action.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.navigateAction, .navigateAction): return {
        guard case .navigateAction(let l) = lhs, case .navigateAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Error from iOS client.
/// Next ID = 5.
public struct Event_IOSError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error code from NSError.
  public var code: Int32 = 0

  /// Error domain from NSError.
  public var domain: String = String()

  /// Description of error.
  public var description_p: String = String()

  /// Which batch generated the error.
  public var batchNumber: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// History of errors from client.
/// Next ID = 3.
public struct Event_ErrorHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Window of latest errors.
  public var iosErrors: [Event_IOSError] = []

  /// Total number of errors encountered.
  public var totalErrors: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Ancestor ID either logged as event or external ID.
/// Next ID = 6.
public struct Event_AncestorIdHistoryItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Changed value of ancestor ID.
  public var ancestorID: String = String()

  /// Event that caused the change, if any.
  public var loggedEvent: Event_AncestorIdHistoryItem.OneOf_LoggedEvent? = nil

  public var userEvent: Event_User {
    get {
      if case .userEvent(let v)? = loggedEvent {return v}
      return Event_User()
    }
    set {loggedEvent = .userEvent(newValue)}
  }

  /// Internally autogenerated session ID.
  public var sessionIDFromUserEvent: String {
    get {
      if case .sessionIDFromUserEvent(let v)? = loggedEvent {return v}
      return String()
    }
    set {loggedEvent = .sessionIDFromUserEvent(newValue)}
  }

  public var viewEvent: Event_View {
    get {
      if case .viewEvent(let v)? = loggedEvent {return v}
      return Event_View()
    }
    set {loggedEvent = .viewEvent(newValue)}
  }

  /// Which batch number the event was logged in
  public var batchNumber: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Event that caused the change, if any.
  public enum OneOf_LoggedEvent: Equatable {
    case userEvent(Event_User)
    /// Internally autogenerated session ID.
    case sessionIDFromUserEvent(String)
    case viewEvent(Event_View)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_AncestorIdHistoryItem.OneOf_LoggedEvent, rhs: Event_AncestorIdHistoryItem.OneOf_LoggedEvent) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userEvent, .userEvent): return {
        guard case .userEvent(let l) = lhs, case .userEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionIDFromUserEvent, .sessionIDFromUserEvent): return {
        guard case .sessionIDFromUserEvent(let l) = lhs, case .sessionIDFromUserEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.viewEvent, .viewEvent): return {
        guard case .viewEvent(let l) = lhs, case .viewEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// History of ancestor IDs logged by client.
/// Next ID = 7.
public struct Event_AncestorIdHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Window of latest log user ids.
  public var logUserIDHistory: [Event_AncestorIdHistoryItem] = []

  /// Total number of log user ids logged this session.
  public var totalLogUserIdsLogged: Int32 = 0

  /// Window of latest session ids.
  public var sessionIDHistory: [Event_AncestorIdHistoryItem] = []

  /// Total number of session ids logged this session.
  public var totalSessionIdsLogged: Int32 = 0

  /// Window of latest view ids.
  public var viewIDHistory: [Event_AncestorIdHistoryItem] = []

  /// Total number of view ids logged this session.
  public var totalViewIdsLogged: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Diagnostic information for mobile clients.
/// Next ID = 9.
public struct Event_MobileDiagnostics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for device sending this message.
  public var deviceIdentifier: String = String()

  /// Version identifier for client app.
  public var clientVersion: String = String()

  /// Version of Promoted library.
  public var promotedLibraryVersion: String = String()

  /// Number of batch logs attempted.
  public var batchesAttempted: Int32 = 0

  /// Number of batch logs sent successfully.
  public var batchesSentSuccessfully: Int32 = 0

  /// Number of batch logs that failed to send.
  public var batchesWithErrors: Int32 = 0

  /// Error history.
  public var errorHistory: Event_ErrorHistory {
    get {return _errorHistory ?? Event_ErrorHistory()}
    set {_errorHistory = newValue}
  }
  /// Returns true if `errorHistory` has been explicitly set.
  public var hasErrorHistory: Bool {return self._errorHistory != nil}
  /// Clears the value of `errorHistory`. Subsequent reads from it will return its default value.
  public mutating func clearErrorHistory() {self._errorHistory = nil}

  /// Ancestor ID history. See #133.
  public var ancestorIDHistory: Event_AncestorIdHistory {
    get {return _ancestorIDHistory ?? Event_AncestorIdHistory()}
    set {_ancestorIDHistory = newValue}
  }
  /// Returns true if `ancestorIDHistory` has been explicitly set.
  public var hasAncestorIDHistory: Bool {return self._ancestorIDHistory != nil}
  /// Clears the value of `ancestorIDHistory`. Subsequent reads from it will return its default value.
  public mutating func clearAncestorIDHistory() {self._ancestorIDHistory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorHistory: Event_ErrorHistory? = nil
  fileprivate var _ancestorIDHistory: Event_AncestorIdHistory? = nil
}

/// Wrapper message for all kinds of diagnostic messages.
/// Next ID = 6.
public struct Event_Diagnostics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common fields.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  public var diagnosticsMessage: OneOf_DiagnosticsMessage? {
    get {return _storage._diagnosticsMessage}
    set {_uniqueStorage()._diagnosticsMessage = newValue}
  }

  public var mobileDiagnostics: Event_MobileDiagnostics {
    get {
      if case .mobileDiagnostics(let v)? = _storage._diagnosticsMessage {return v}
      return Event_MobileDiagnostics()
    }
    set {_uniqueStorage()._diagnosticsMessage = .mobileDiagnostics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_DiagnosticsMessage: Equatable {
    case mobileDiagnostics(Event_MobileDiagnostics)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_Diagnostics.OneOf_DiagnosticsMessage, rhs: Event_Diagnostics.OneOf_DiagnosticsMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mobileDiagnostics, .mobileDiagnostics): return {
        guard case .mobileDiagnostics(let l) = lhs, case .mobileDiagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A way to batch up log requests into the same request.
/// Clients can reference logs in different batches.
/// Keep in sync with FlatEvent.
/// Next ID = 24.
public struct Event_LogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses the value set on each log record.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on each child log record or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses the value set on each log record.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Optional.
  public var clientInfo: Common_ClientInfo {
    get {return _clientInfo ?? Common_ClientInfo()}
    set {_clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return self._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {self._clientInfo = nil}

  public var user: [Event_User] = []

  public var cohortMembership: [Event_CohortMembership] = []

  public var view: [Event_View] = []

  public var request: [Delivery_Request] = []

  public var insertion: [Delivery_Insertion] = []

  public var impression: [Event_Impression] = []

  public var action: [Event_Action] = []

  public var diagnostics: [Event_Diagnostics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _clientInfo: Common_ClientInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "event"

extension Event_CohortArm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_GROUP"),
    1: .same(proto: "CONTROL"),
    2: .same(proto: "TREATMENT"),
    3: .same(proto: "TREATMENT1"),
    4: .same(proto: "TREATMENT2"),
    5: .same(proto: "TREATMENT3"),
  ]
}

extension Event_DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DEVICE_TYPE"),
    1: .same(proto: "DESKTOP"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "TABLET"),
  ]
}

extension Event_ImpressionSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_IMPRESSION_SOURCE_TYPE"),
    1: .same(proto: "DELIVERY"),
    2: .same(proto: "CLIENT_BACKEND"),
  ]
}

extension Event_ActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTION_TYPE"),
    1: .same(proto: "CUSTOM_ACTION_TYPE"),
    2: .same(proto: "NAVIGATE"),
    3: .same(proto: "PURCHASE"),
    4: .same(proto: "ADD_TO_CART"),
    5: .same(proto: "SHARE"),
    6: .same(proto: "LIKE"),
    7: .same(proto: "COMMENT"),
    8: .same(proto: "CHECKOUT"),
    9: .same(proto: "UNLIKE"),
    10: .same(proto: "REMOVE_FROM_CART"),
    11: .same(proto: "MAKE_OFFER"),
    12: .same(proto: "ASK_QUESTION"),
    13: .same(proto: "ANSWER_QUESTION"),
    14: .same(proto: "COMPLETE_SIGN_IN"),
    15: .same(proto: "COMPLETE_SIGN_UP"),
  ]
}

extension Event_JoinedIdentifiers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinedIdentifiers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "session_id"),
    5: .standard(proto: "view_id"),
    6: .standard(proto: "request_id"),
    7: .standard(proto: "insertion_id"),
    8: .standard(proto: "impression_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 7)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_JoinedIdentifiers, rhs: Event_JoinedIdentifiers) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientInfo) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._clientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_User, rhs: Event_User) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs._clientInfo != rhs._clientInfo {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_CohortMembership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CohortMembership"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "membership_id"),
    8: .standard(proto: "cohort_id"),
    9: .same(proto: "arm"),
    10: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientInfo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.membershipID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cohortID) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.arm) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._clientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.membershipID.isEmpty {
      try visitor.visitSingularStringField(value: self.membershipID, fieldNumber: 6)
    }
    if !self.cohortID.isEmpty {
      try visitor.visitSingularStringField(value: self.cohortID, fieldNumber: 8)
    }
    if self.arm != .unknownGroup {
      try visitor.visitSingularEnumField(value: self.arm, fieldNumber: 9)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_CohortMembership, rhs: Event_CohortMembership) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs._clientInfo != rhs._clientInfo {return false}
    if lhs.membershipID != rhs.membershipID {return false}
    if lhs.cohortID != rhs.cohortID {return false}
    if lhs.arm != rhs.arm {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Locale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Locale"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "language_code"),
    2: .standard(proto: "region_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Locale, rhs: Event_Locale) -> Bool {
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Size"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Size, rhs: Event_Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Screen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Screen, rhs: Event_Screen) -> Bool {
    if lhs._size != rhs._size {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_type"),
    2: .same(proto: "brand"),
    3: .same(proto: "manufacturer"),
    4: .same(proto: "identifier"),
    5: .standard(proto: "os_version"),
    6: .same(proto: "locale"),
    7: .same(proto: "screen"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.manufacturer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._locale) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceType != .unknownDeviceType {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 1)
    }
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 2)
    }
    if !self.manufacturer.isEmpty {
      try visitor.visitSingularStringField(value: self.manufacturer, fieldNumber: 3)
    }
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if let v = self._locale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Device, rhs: Event_Device) -> Bool {
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.manufacturer != rhs.manufacturer {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs._locale != rhs._locale {return false}
    if lhs._screen != rhs._screen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ClientHints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_mobile"),
    2: .same(proto: "brand"),
    3: .same(proto: "architecture"),
    4: .same(proto: "model"),
    5: .same(proto: "platform"),
    6: .standard(proto: "platform_version"),
    7: .standard(proto: "ua_full_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isMobile) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.brand) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.platformVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.uaFullVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMobile != false {
      try visitor.visitSingularBoolField(value: self.isMobile, fieldNumber: 1)
    }
    if !self.brand.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.brand, fieldNumber: 2)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 3)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 4)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 5)
    }
    if !self.platformVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.platformVersion, fieldNumber: 6)
    }
    if !self.uaFullVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.uaFullVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ClientHints, rhs: Event_ClientHints) -> Bool {
    if lhs.isMobile != rhs.isMobile {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.model != rhs.model {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.platformVersion != rhs.platformVersion {return false}
    if lhs.uaFullVersion != rhs.uaFullVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ClientHintBrand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHintBrand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brand"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ClientHintBrand, rhs: Event_ClientHintBrand) -> Bool {
    if lhs.brand != rhs.brand {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Browser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Browser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_agent"),
    2: .standard(proto: "viewport_size"),
    3: .standard(proto: "client_hints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._viewportSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientHints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 1)
    }
    if let v = self._viewportSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._clientHints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Browser, rhs: Event_Browser) -> Bool {
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs._viewportSize != rhs._viewportSize {return false}
    if lhs._clientHints != rhs._clientHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Location, rhs: Event_Location) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_WebPageView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebPageView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "browser"),
    3: .same(proto: "referrer"),
    4: .standard(proto: "document_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.referrer) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._documentSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.referrer.isEmpty {
      try visitor.visitSingularStringField(value: self.referrer, fieldNumber: 3)
    }
    if let v = self._documentSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_WebPageView, rhs: Event_WebPageView) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs.referrer != rhs.referrer {return false}
    if lhs._documentSize != rhs._documentSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_AppScreenView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppScreenView"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AppScreenView, rhs: Event_AppScreenView) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".View"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "view_id"),
    7: .standard(proto: "session_id"),
    8: .same(proto: "name"),
    9: .standard(proto: "use_case"),
    10: .standard(proto: "search_query"),
    11: .same(proto: "properties"),
    12: .same(proto: "device"),
    16: .same(proto: "locale"),
    13: .standard(proto: "view_type"),
    14: .standard(proto: "web_page_view"),
    15: .standard(proto: "app_screen_view"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _viewID: String = String()
    var _sessionID: String = String()
    var _name: String = String()
    var _useCase: Delivery_UseCase = .unknownUseCase
    var _searchQuery: String = String()
    var _properties: Common_Properties? = nil
    var _device: Event_Device? = nil
    var _locale: Event_Locale? = nil
    var _viewType: Event_View.ViewType = .unknownViewType
    var _uiType: Event_View.OneOf_UiType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _viewID = source._viewID
      _sessionID = source._sessionID
      _name = source._name
      _useCase = source._useCase
      _searchQuery = source._searchQuery
      _properties = source._properties
      _device = source._device
      _locale = source._locale
      _viewType = source._viewType
      _uiType = source._uiType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._useCase) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._searchQuery) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._viewType) }()
        case 14: try {
          var v: Event_WebPageView?
          var hadOneofValue = false
          if let current = _storage._uiType {
            hadOneofValue = true
            if case .webPageView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._uiType = .webPageView(v)
          }
        }()
        case 15: try {
          var v: Event_AppScreenView?
          var hadOneofValue = false
          if let current = _storage._uiType {
            hadOneofValue = true
            if case .appScreenView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._uiType = .appScreenView(v)
          }
        }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._locale) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 6)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 7)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      if _storage._useCase != .unknownUseCase {
        try visitor.visitSingularEnumField(value: _storage._useCase, fieldNumber: 9)
      }
      if !_storage._searchQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._searchQuery, fieldNumber: 10)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._viewType != .unknownViewType {
        try visitor.visitSingularEnumField(value: _storage._viewType, fieldNumber: 13)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._uiType {
      case .webPageView?: try {
        guard case .webPageView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .appScreenView?: try {
        guard case .appScreenView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case nil: break
      }
      if let v = _storage._locale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_View, rhs: Event_View) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._useCase != rhs_storage._useCase {return false}
        if _storage._searchQuery != rhs_storage._searchQuery {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._viewType != rhs_storage._viewType {return false}
        if _storage._uiType != rhs_storage._uiType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View.ViewType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VIEW_TYPE"),
    1: .same(proto: "WEB_PAGE"),
    2: .same(proto: "APP_SCREEN"),
  ]
}

extension Event_Impression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Impression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "impression_id"),
    7: .standard(proto: "insertion_id"),
    8: .standard(proto: "request_id"),
    10: .standard(proto: "view_id"),
    9: .standard(proto: "session_id"),
    12: .standard(proto: "content_id"),
    13: .standard(proto: "source_type"),
    11: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientInfo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.sourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._clientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 6)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 7)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 8)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 9)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 10)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 12)
    }
    if self.sourceType != .unknownImpressionSourceType {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Impression, rhs: Event_Impression) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs._clientInfo != rhs._clientInfo {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_NavigateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigateAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetURL.isEmpty {
      try visitor.visitSingularStringField(value: self.targetURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_NavigateAction, rhs: Event_NavigateAction) -> Bool {
    if lhs.targetURL != rhs.targetURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "action_id"),
    7: .standard(proto: "impression_id"),
    8: .standard(proto: "insertion_id"),
    9: .standard(proto: "request_id"),
    11: .standard(proto: "view_id"),
    10: .standard(proto: "session_id"),
    21: .standard(proto: "content_id"),
    12: .same(proto: "name"),
    14: .standard(proto: "action_type"),
    15: .standard(proto: "custom_action_type"),
    17: .standard(proto: "element_id"),
    18: .standard(proto: "navigate_action"),
    20: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _actionID: String = String()
    var _impressionID: String = String()
    var _insertionID: String = String()
    var _requestID: String = String()
    var _viewID: String = String()
    var _sessionID: String = String()
    var _contentID: String = String()
    var _name: String = String()
    var _actionType: Event_ActionType = .unknownActionType
    var _customActionType: String = String()
    var _elementID: String = String()
    var _action: Event_Action.OneOf_Action?
    var _properties: Common_Properties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _actionID = source._actionID
      _impressionID = source._impressionID
      _insertionID = source._insertionID
      _requestID = source._requestID
      _viewID = source._viewID
      _sessionID = source._sessionID
      _contentID = source._contentID
      _name = source._name
      _actionType = source._actionType
      _customActionType = source._customActionType
      _elementID = source._elementID
      _action = source._action
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._actionID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._impressionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._insertionID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._actionType) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._customActionType) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._elementID) }()
        case 18: try {
          var v: Event_NavigateAction?
          var hadOneofValue = false
          if let current = _storage._action {
            hadOneofValue = true
            if case .navigateAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._action = .navigateAction(v)
          }
        }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._contentID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._actionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionID, fieldNumber: 6)
      }
      if !_storage._impressionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._impressionID, fieldNumber: 7)
      }
      if !_storage._insertionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._insertionID, fieldNumber: 8)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 9)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 10)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 11)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 12)
      }
      if _storage._actionType != .unknownActionType {
        try visitor.visitSingularEnumField(value: _storage._actionType, fieldNumber: 14)
      }
      if !_storage._customActionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customActionType, fieldNumber: 15)
      }
      if !_storage._elementID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._elementID, fieldNumber: 17)
      }
      if case .navigateAction(let v)? = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._contentID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentID, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Action, rhs: Event_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._actionID != rhs_storage._actionID {return false}
        if _storage._impressionID != rhs_storage._impressionID {return false}
        if _storage._insertionID != rhs_storage._insertionID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._contentID != rhs_storage._contentID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._actionType != rhs_storage._actionType {return false}
        if _storage._customActionType != rhs_storage._customActionType {return false}
        if _storage._elementID != rhs_storage._elementID {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_IOSError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IOSError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "domain"),
    3: .same(proto: "description"),
    4: .standard(proto: "batch_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.batchNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.batchNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.batchNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_IOSError, rhs: Event_IOSError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.batchNumber != rhs.batchNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ErrorHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ios_errors"),
    2: .standard(proto: "total_errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.iosErrors) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalErrors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.iosErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iosErrors, fieldNumber: 1)
    }
    if self.totalErrors != 0 {
      try visitor.visitSingularInt32Field(value: self.totalErrors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ErrorHistory, rhs: Event_ErrorHistory) -> Bool {
    if lhs.iosErrors != rhs.iosErrors {return false}
    if lhs.totalErrors != rhs.totalErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_AncestorIdHistoryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AncestorIdHistoryItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ancestor_id"),
    2: .standard(proto: "user_event"),
    3: .standard(proto: "session_id_from_user_event"),
    4: .standard(proto: "view_event"),
    5: .standard(proto: "batch_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ancestorID) }()
      case 2: try {
        var v: Event_User?
        var hadOneofValue = false
        if let current = self.loggedEvent {
          hadOneofValue = true
          if case .userEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.loggedEvent = .userEvent(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.loggedEvent != nil {try decoder.handleConflictingOneOf()}
          self.loggedEvent = .sessionIDFromUserEvent(v)
        }
      }()
      case 4: try {
        var v: Event_View?
        var hadOneofValue = false
        if let current = self.loggedEvent {
          hadOneofValue = true
          if case .viewEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.loggedEvent = .viewEvent(v)
        }
      }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.batchNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ancestorID.isEmpty {
      try visitor.visitSingularStringField(value: self.ancestorID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.loggedEvent {
    case .userEvent?: try {
      guard case .userEvent(let v)? = self.loggedEvent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sessionIDFromUserEvent?: try {
      guard case .sessionIDFromUserEvent(let v)? = self.loggedEvent else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .viewEvent?: try {
      guard case .viewEvent(let v)? = self.loggedEvent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.batchNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.batchNumber, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AncestorIdHistoryItem, rhs: Event_AncestorIdHistoryItem) -> Bool {
    if lhs.ancestorID != rhs.ancestorID {return false}
    if lhs.loggedEvent != rhs.loggedEvent {return false}
    if lhs.batchNumber != rhs.batchNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_AncestorIdHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AncestorIdHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_user_id_history"),
    2: .standard(proto: "total_log_user_ids_logged"),
    3: .standard(proto: "session_id_history"),
    4: .standard(proto: "total_session_ids_logged"),
    5: .standard(proto: "view_id_history"),
    6: .standard(proto: "total_view_ids_logged"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logUserIDHistory) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalLogUserIdsLogged) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sessionIDHistory) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalSessionIdsLogged) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.viewIDHistory) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.totalViewIdsLogged) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logUserIDHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logUserIDHistory, fieldNumber: 1)
    }
    if self.totalLogUserIdsLogged != 0 {
      try visitor.visitSingularInt32Field(value: self.totalLogUserIdsLogged, fieldNumber: 2)
    }
    if !self.sessionIDHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionIDHistory, fieldNumber: 3)
    }
    if self.totalSessionIdsLogged != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSessionIdsLogged, fieldNumber: 4)
    }
    if !self.viewIDHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.viewIDHistory, fieldNumber: 5)
    }
    if self.totalViewIdsLogged != 0 {
      try visitor.visitSingularInt32Field(value: self.totalViewIdsLogged, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AncestorIdHistory, rhs: Event_AncestorIdHistory) -> Bool {
    if lhs.logUserIDHistory != rhs.logUserIDHistory {return false}
    if lhs.totalLogUserIdsLogged != rhs.totalLogUserIdsLogged {return false}
    if lhs.sessionIDHistory != rhs.sessionIDHistory {return false}
    if lhs.totalSessionIdsLogged != rhs.totalSessionIdsLogged {return false}
    if lhs.viewIDHistory != rhs.viewIDHistory {return false}
    if lhs.totalViewIdsLogged != rhs.totalViewIdsLogged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_MobileDiagnostics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileDiagnostics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_identifier"),
    2: .standard(proto: "client_version"),
    3: .standard(proto: "promoted_library_version"),
    4: .standard(proto: "batches_attempted"),
    5: .standard(proto: "batches_sent_successfully"),
    6: .standard(proto: "batches_with_errors"),
    7: .standard(proto: "error_history"),
    8: .standard(proto: "ancestor_id_history"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.promotedLibraryVersion) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.batchesAttempted) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.batchesSentSuccessfully) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.batchesWithErrors) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._errorHistory) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._ancestorIDHistory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceIdentifier, fieldNumber: 1)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 2)
    }
    if !self.promotedLibraryVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.promotedLibraryVersion, fieldNumber: 3)
    }
    if self.batchesAttempted != 0 {
      try visitor.visitSingularInt32Field(value: self.batchesAttempted, fieldNumber: 4)
    }
    if self.batchesSentSuccessfully != 0 {
      try visitor.visitSingularInt32Field(value: self.batchesSentSuccessfully, fieldNumber: 5)
    }
    if self.batchesWithErrors != 0 {
      try visitor.visitSingularInt32Field(value: self.batchesWithErrors, fieldNumber: 6)
    }
    if let v = self._errorHistory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._ancestorIDHistory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_MobileDiagnostics, rhs: Event_MobileDiagnostics) -> Bool {
    if lhs.deviceIdentifier != rhs.deviceIdentifier {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.promotedLibraryVersion != rhs.promotedLibraryVersion {return false}
    if lhs.batchesAttempted != rhs.batchesAttempted {return false}
    if lhs.batchesSentSuccessfully != rhs.batchesSentSuccessfully {return false}
    if lhs.batchesWithErrors != rhs.batchesWithErrors {return false}
    if lhs._errorHistory != rhs._errorHistory {return false}
    if lhs._ancestorIDHistory != rhs._ancestorIDHistory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Diagnostics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Diagnostics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    5: .standard(proto: "mobile_diagnostics"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _diagnosticsMessage: Event_Diagnostics.OneOf_DiagnosticsMessage?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _diagnosticsMessage = source._diagnosticsMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 5: try {
          var v: Event_MobileDiagnostics?
          var hadOneofValue = false
          if let current = _storage._diagnosticsMessage {
            hadOneofValue = true
            if case .mobileDiagnostics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._diagnosticsMessage = .mobileDiagnostics(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if case .mobileDiagnostics(let v)? = _storage._diagnosticsMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Diagnostics, rhs: Event_Diagnostics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._diagnosticsMessage != rhs_storage._diagnosticsMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    7: .same(proto: "user"),
    8: .standard(proto: "cohort_membership"),
    11: .same(proto: "view"),
    12: .same(proto: "request"),
    13: .same(proto: "insertion"),
    14: .same(proto: "impression"),
    15: .same(proto: "action"),
    23: .same(proto: "diagnostics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientInfo) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.user) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.cohortMembership) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.view) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.request) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.insertion) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.impression) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.action) }()
      case 23: try { try decoder.decodeRepeatedMessageField(value: &self.diagnostics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._clientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.user.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.user, fieldNumber: 7)
    }
    if !self.cohortMembership.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cohortMembership, fieldNumber: 8)
    }
    if !self.view.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.view, fieldNumber: 11)
    }
    if !self.request.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.request, fieldNumber: 12)
    }
    if !self.insertion.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertion, fieldNumber: 13)
    }
    if !self.impression.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.impression, fieldNumber: 14)
    }
    if !self.action.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.action, fieldNumber: 15)
    }
    if !self.diagnostics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.diagnostics, fieldNumber: 23)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LogRequest, rhs: Event_LogRequest) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs._clientInfo != rhs._clientInfo {return false}
    if lhs.user != rhs.user {return false}
    if lhs.cohortMembership != rhs.cohortMembership {return false}
    if lhs.view != rhs.view {return false}
    if lhs.request != rhs.request {return false}
    if lhs.insertion != rhs.insertion {return false}
    if lhs.impression != rhs.impression {return false}
    if lhs.action != rhs.action {return false}
    if lhs.diagnostics != rhs.diagnostics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
