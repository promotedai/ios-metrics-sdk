// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/event/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Indicates the value of IDs when logged from metrics client library.
/// Used for diagnostics and validation to show where IDs are being set.
/// Next ID = 5;
public enum Event_IdentifierProvenance: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Set to null by platform code.
  case null // = 1

  /// Set to the empty string by platform integration code.
  case empty // = 2

  /// Automatically generated by metrics library.
  case autogenerated // = 3

  /// Set to a specific value by platform integration code.
  case platformSpecified // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .null
    case 2: self = .empty
    case 3: self = .autogenerated
    case 4: self = .platformSpecified
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .null: return 1
    case .empty: return 2
    case .autogenerated: return 3
    case .platformSpecified: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_IdentifierProvenance: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_IdentifierProvenance] = [
    .unknown,
    .null,
    .empty,
    .autogenerated,
    .platformSpecified,
  ]
}

#endif  // swift(>=4.2)

/// The arm (experiment's group) when the Cohort is for an experiment.
/// Next ID = 6.
public enum Event_CohortArm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownGroup // = 0
  case control // = 1
  case treatment // = 2

  /// These are generic arms (groups) that can be used when there are multiple treatments.
  case treatment1 // = 3
  case treatment2 // = 4
  case treatment3 // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownGroup
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownGroup
    case 1: self = .control
    case 2: self = .treatment
    case 3: self = .treatment1
    case 4: self = .treatment2
    case 5: self = .treatment3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownGroup: return 0
    case .control: return 1
    case .treatment: return 2
    case .treatment1: return 3
    case .treatment2: return 4
    case .treatment3: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_CohortArm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_CohortArm] = [
    .unknownGroup,
    .control,
    .treatment,
    .treatment1,
    .treatment2,
    .treatment3,
  ]
}

#endif  // swift(>=4.2)

/// Contextual information about where impression was served.
/// Allows backends to infer expected behavior about
/// corresponding content.
/// Next ID = 3.
public enum Event_ImpressionSourceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownImpressionSourceType // = 0

  /// Content was served by Promoted Delivery API.
  case delivery // = 1

  /// Content was not served by Promoted Delivery API.
  case clientBackend // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownImpressionSourceType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownImpressionSourceType
    case 1: self = .delivery
    case 2: self = .clientBackend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownImpressionSourceType: return 0
    case .delivery: return 1
    case .clientBackend: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_ImpressionSourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_ImpressionSourceType] = [
    .unknownImpressionSourceType,
    .delivery,
    .clientBackend,
  ]
}

#endif  // swift(>=4.2)

/// The action that user wants to perform.
///
/// Next ID = 16.
public enum Event_ActionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownActionType // = 0

  /// Action that doesn't correspond to any of the below.
  case customActionType // = 1

  /// Navigating to details about content.
  case navigate // = 2

  /// Adding an item to shopping cart.
  case addToCart // = 4

  /// Remove an item from shopping cart.
  case removeFromCart // = 10

  /// Going to checkout.
  case checkout // = 8

  /// Purchasing an item.
  case purchase // = 3

  /// Sharing content.
  case share // = 5

  /// Liking content.
  case like // = 6

  /// Un-liking content.
  case unlike // = 9

  /// Commenting on content.
  case comment // = 7

  /// Making an offer on content.
  case makeOffer // = 11

  /// Asking a question about content.
  case askQuestion // = 12

  /// Answering a question about content.
  case answerQuestion // = 13

  /// Complete sign-in.
  /// No content_id needed.  If set, set it to the Content's ID (not User).
  case completeSignIn // = 14

  /// Complete sign-up.
  /// No content_id needed.  If set, set it to the Content's ID (not User).
  case completeSignUp // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownActionType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownActionType
    case 1: self = .customActionType
    case 2: self = .navigate
    case 3: self = .purchase
    case 4: self = .addToCart
    case 5: self = .share
    case 6: self = .like
    case 7: self = .comment
    case 8: self = .checkout
    case 9: self = .unlike
    case 10: self = .removeFromCart
    case 11: self = .makeOffer
    case 12: self = .askQuestion
    case 13: self = .answerQuestion
    case 14: self = .completeSignIn
    case 15: self = .completeSignUp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownActionType: return 0
    case .customActionType: return 1
    case .navigate: return 2
    case .purchase: return 3
    case .addToCart: return 4
    case .share: return 5
    case .like: return 6
    case .comment: return 7
    case .checkout: return 8
    case .unlike: return 9
    case .removeFromCart: return 10
    case .makeOffer: return 11
    case .askQuestion: return 12
    case .answerQuestion: return 13
    case .completeSignIn: return 14
    case .completeSignUp: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_ActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_ActionType] = [
    .unknownActionType,
    .customActionType,
    .navigate,
    .addToCart,
    .removeFromCart,
    .checkout,
    .purchase,
    .share,
    .like,
    .unlike,
    .comment,
    .makeOffer,
    .askQuestion,
    .answerQuestion,
    .completeSignIn,
    .completeSignUp,
  ]
}

#endif  // swift(>=4.2)

/// This structure is used to help deduplicate identifiers that live in many
/// event types.
/// Next ID = 10.
public struct Event_JoinedIdentifiers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformID: UInt64 = 0

  public var userID: String = String()

  public var logUserID: String = String()

  public var sessionID: String = String()

  public var viewID: String = String()

  public var autoViewID: String = String()

  public var requestID: String = String()

  public var insertionID: String = String()

  public var impressionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Diagnostics message indicating where each of an event's IDs originated
/// from in metrics client library.
/// Next ID = 11;
public struct Event_IdentifierProvenances {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userIDProvenance: Event_IdentifierProvenance = .unknown

  public var logUserIDProvenance: Event_IdentifierProvenance = .unknown

  public var sessionIDProvenance: Event_IdentifierProvenance = .unknown

  public var viewIDProvenance: Event_IdentifierProvenance = .unknown

  public var autoViewIDProvenance: Event_IdentifierProvenance = .unknown

  public var insertionIDProvenance: Event_IdentifierProvenance = .unknown

  public var impressionIDProvenance: Event_IdentifierProvenance = .unknown

  public var actionIDProvenance: Event_IdentifierProvenance = .unknown

  public var contentIDProvenance: Event_IdentifierProvenance = .unknown

  public var requestIDProvenance: Event_IdentifierProvenance = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to store user properties.  E.g. purchasedContentIds.
/// Clients can update each User multiple times by logging the User with the same
/// user_id.  Unset fields will not be updated. Repeated fields will act like a
/// merge if the item has a key.  Otherwise, it'll act like an append.
/// Next ID = 8.
public struct Event_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional.  Used for debugging.
  public var idProvenances: Event_IdentifierProvenances {
    get {return _storage._idProvenances ?? Event_IdentifierProvenances()}
    set {_uniqueStorage()._idProvenances = newValue}
  }
  /// Returns true if `idProvenances` has been explicitly set.
  public var hasIDProvenances: Bool {return _storage._idProvenances != nil}
  /// Clears the value of `idProvenances`. Subsequent reads from it will return its default value.
  public mutating func clearIDProvenances() {_uniqueStorage()._idProvenances = nil}

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// For linking users to cohorts.
/// Next ID = 11.
public struct Event_CohortMembership {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _clientInfo ?? Common_ClientInfo()}
    set {_clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return self._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {self._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var membershipID: String = String()

  /// Optional.  This field refers to the cohort (currently stored as an enum).
  public var cohortID: String = String()

  /// Optional.
  public var arm: Event_CohortArm = .unknownGroup

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _clientInfo: Common_ClientInfo? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// Submessage on View for Web page visits.
/// Next ID = 5.
public struct Event_WebPageView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  This is the url for the page.
  public var url: String = String()

  /// Optional.  Can be a full referrer string.  Could be just the UTM.
  public var referrer: String = String()

  public var documentSize: Common_Size {
    get {return _documentSize ?? Common_Size()}
    set {_documentSize = newValue}
  }
  /// Returns true if `documentSize` has been explicitly set.
  public var hasDocumentSize: Bool {return self._documentSize != nil}
  /// Clears the value of `documentSize`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentSize() {self._documentSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _documentSize: Common_Size? = nil
}

/// Submessage on View for screen views.
/// Next ID = 2.
public struct Event_AppScreenView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A view of a single page/screen (e.g. feed, search results, etc).
/// Next ID = 19.
public struct Event_View {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.  Do not set this outside the client SDK.
  public var autoViewID: String {
    get {return _storage._autoViewID}
    set {_uniqueStorage()._autoViewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional.  The name of the view.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.
  public var useCase: Delivery_UseCase {
    get {return _storage._useCase}
    set {_uniqueStorage()._useCase = newValue}
  }

  /// Optional.
  public var searchQuery: String {
    get {return _storage._searchQuery}
    set {_uniqueStorage()._searchQuery = newValue}
  }

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  /// Optional.
  public var locale: Common_Locale {
    get {return _storage._locale ?? Common_Locale()}
    set {_uniqueStorage()._locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return _storage._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {_uniqueStorage()._locale = nil}

  /// If a specific view is set (`web_page_view` and `app_screen_view`),
  /// clients do not need to set it directly.  If those fields and `view_type`
  /// have conflicting values, the specific view field is used.
  public var viewType: Event_View.ViewType {
    get {return _storage._viewType}
    set {_uniqueStorage()._viewType = newValue}
  }

  /// Optional.
  public var uiType: OneOf_UiType? {
    get {return _storage._uiType}
    set {_uniqueStorage()._uiType = newValue}
  }

  public var webPageView: Event_WebPageView {
    get {
      if case .webPageView(let v)? = _storage._uiType {return v}
      return Event_WebPageView()
    }
    set {_uniqueStorage()._uiType = .webPageView(newValue)}
  }

  public var appScreenView: Event_AppScreenView {
    get {
      if case .appScreenView(let v)? = _storage._uiType {return v}
      return Event_AppScreenView()
    }
    set {_uniqueStorage()._uiType = .appScreenView(newValue)}
  }

  /// Optional.  Used for debugging.
  public var idProvenances: Event_IdentifierProvenances {
    get {return _storage._idProvenances ?? Event_IdentifierProvenances()}
    set {_uniqueStorage()._idProvenances = newValue}
  }
  /// Returns true if `idProvenances` has been explicitly set.
  public var hasIDProvenances: Bool {return _storage._idProvenances != nil}
  /// Clears the value of `idProvenances`. Subsequent reads from it will return its default value.
  public mutating func clearIDProvenances() {_uniqueStorage()._idProvenances = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Optional.
  public enum OneOf_UiType: Equatable {
    case webPageView(Event_WebPageView)
    case appScreenView(Event_AppScreenView)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_View.OneOf_UiType, rhs: Event_View.OneOf_UiType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.webPageView, .webPageView): return {
        guard case .webPageView(let l) = lhs, case .webPageView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appScreenView, .appScreenView): return {
        guard case .appScreenView(let l) = lhs, case .appScreenView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ViewType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownViewType // = 0
    case webPage // = 1
    case appScreen // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownViewType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownViewType
      case 1: self = .webPage
      case 2: self = .appScreen
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownViewType: return 0
      case .webPage: return 1
      case .appScreen: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Event_View.ViewType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_View.ViewType] = [
    .unknownViewType,
    .webPage,
    .appScreen,
  ]
}

#endif  // swift(>=4.2)

/// An automatically generated view logged by web and mobile SDKs.
/// Platform clients should never log this directly. Let the SDKs
/// handle this instead.
/// Next ID = 16.
public struct Event_AutoView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var autoViewID: String {
    get {return _storage._autoViewID}
    set {_uniqueStorage()._autoViewID = newValue}
  }

  /// Optional.  Do not set this outside the client SDK.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional.  The name of the view.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.
  public var useCase: Delivery_UseCase {
    get {return _storage._useCase}
    set {_uniqueStorage()._useCase = newValue}
  }

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  /// Optional.
  public var locale: Common_Locale {
    get {return _storage._locale ?? Common_Locale()}
    set {_uniqueStorage()._locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return _storage._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {_uniqueStorage()._locale = nil}

  /// Optional.
  public var uiType: OneOf_UiType? {
    get {return _storage._uiType}
    set {_uniqueStorage()._uiType = newValue}
  }

  public var webPageView: Event_WebPageView {
    get {
      if case .webPageView(let v)? = _storage._uiType {return v}
      return Event_WebPageView()
    }
    set {_uniqueStorage()._uiType = .webPageView(newValue)}
  }

  public var appScreenView: Event_AppScreenView {
    get {
      if case .appScreenView(let v)? = _storage._uiType {return v}
      return Event_AppScreenView()
    }
    set {_uniqueStorage()._uiType = .appScreenView(newValue)}
  }

  /// Optional.  Used for debugging.
  public var idProvenances: Event_IdentifierProvenances {
    get {return _storage._idProvenances ?? Event_IdentifierProvenances()}
    set {_uniqueStorage()._idProvenances = newValue}
  }
  /// Returns true if `idProvenances` has been explicitly set.
  public var hasIDProvenances: Bool {return _storage._idProvenances != nil}
  /// Clears the value of `idProvenances`. Subsequent reads from it will return its default value.
  public mutating func clearIDProvenances() {_uniqueStorage()._idProvenances = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Optional.
  public enum OneOf_UiType: Equatable {
    case webPageView(Event_WebPageView)
    case appScreenView(Event_AppScreenView)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_AutoView.OneOf_UiType, rhs: Event_AutoView.OneOf_UiType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.webPageView, .webPageView): return {
        guard case .webPageView(let l) = lhs, case .webPageView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appScreenView, .appScreenView): return {
        guard case .appScreenView(let l) = lhs, case .appScreenView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a position in a list view, most commonly used with
/// mobile clients (though it can apply to web too).
/// The indexes represent a zero-based hierarchical path of sections,
/// subsections, and items. For example:
/// [2] -> Item at index 2 in a flat list
/// [0, 1] -> Section 0, item 1 in a sectioned list
/// [0, 1, 5] -> Section 0, subsection 1, item 5 in a sectioned list
/// Next ID = 2.
public struct Event_IndexPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index of item in path.
  public var index: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// When an Insertion (instance of Content) is shown to a user.
/// Impressions are immutable.
/// Next ID = 18.
public struct Event_Impression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var impressionID: String {
    get {return _storage._impressionID}
    set {_uniqueStorage()._impressionID = newValue}
  }

  /// Optional.
  public var insertionID: String {
    get {return _storage._insertionID}
    set {_uniqueStorage()._insertionID = newValue}
  }

  /// Optional.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Optional.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var autoViewID: String {
    get {return _storage._autoViewID}
    set {_uniqueStorage()._autoViewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional. content_id is used as a hint when insertion_id is not set.
  /// For more accurate results, set insertion_id.
  public var contentID: String {
    get {return _storage._contentID}
    set {_uniqueStorage()._contentID = newValue}
  }

  /// Optional.
  public var sourceType: Event_ImpressionSourceType {
    get {return _storage._sourceType}
    set {_uniqueStorage()._sourceType = newValue}
  }

  /// Optional. Indicates that this impression occurred in a view that may
  /// not be topmost in the view hierarchy, and thus may have been obscured
  /// from the user.
  public var hasSuperimposedViews_p: Bool {
    get {return _storage._hasSuperimposedViews_p}
    set {_uniqueStorage()._hasSuperimposedViews_p = newValue}
  }

  /// Optional. Position the the impression within its enclosing list.
  public var clientPosition: Event_IndexPath {
    get {return _storage._clientPosition ?? Event_IndexPath()}
    set {_uniqueStorage()._clientPosition = newValue}
  }
  /// Returns true if `clientPosition` has been explicitly set.
  public var hasClientPosition: Bool {return _storage._clientPosition != nil}
  /// Clears the value of `clientPosition`. Subsequent reads from it will return its default value.
  public mutating func clearClientPosition() {_uniqueStorage()._clientPosition = nil}

  /// Optional.  Used for debugging.
  public var idProvenances: Event_IdentifierProvenances {
    get {return _storage._idProvenances ?? Event_IdentifierProvenances()}
    set {_uniqueStorage()._idProvenances = newValue}
  }
  /// Returns true if `idProvenances` has been explicitly set.
  public var hasIDProvenances: Bool {return _storage._idProvenances != nil}
  /// Clears the value of `idProvenances`. Subsequent reads from it will return its default value.
  public mutating func clearIDProvenances() {_uniqueStorage()._idProvenances = nil}

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next ID = 2.
public struct Event_NavigateAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  The next URL.
  public var targetURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Actions are user actions.  Example: Click.
/// Actions are immutable.
/// Next ID = 26.
public struct Event_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.  If not set, API server uses LogRequest.client_info.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional.  Primary key.
  /// SDKs usually handles this automatically. For details, see
  /// https://github.com/promotedai/schema#setting-primary-keys
  public var actionID: String {
    get {return _storage._actionID}
    set {_uniqueStorage()._actionID = newValue}
  }

  /// Optional.
  public var impressionID: String {
    get {return _storage._impressionID}
    set {_uniqueStorage()._impressionID = newValue}
  }

  /// Optional.
  public var insertionID: String {
    get {return _storage._insertionID}
    set {_uniqueStorage()._insertionID = newValue}
  }

  /// Optional.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Optional.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var autoViewID: String {
    get {return _storage._autoViewID}
    set {_uniqueStorage()._autoViewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional. content_id is used as a hint when impression_id is not set.
  /// For more accurate results, set impression_id if available.
  public var contentID: String {
    get {return _storage._contentID}
    set {_uniqueStorage()._contentID = newValue}
  }

  /// Optional.  Custom name of the action that the user performed.
  /// E.g. "Product clicked".  Do not stick parameters or pii in this name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.  The action that the user wants to perform.
  public var actionType: Event_ActionType {
    get {return _storage._actionType}
    set {_uniqueStorage()._actionType = newValue}
  }

  /// Optional.
  public var customActionType: String {
    get {return _storage._customActionType}
    set {_uniqueStorage()._customActionType = newValue}
  }

  public var elementID: String {
    get {return _storage._elementID}
    set {_uniqueStorage()._elementID = newValue}
  }

  public var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var navigateAction: Event_NavigateAction {
    get {
      if case .navigateAction(let v)? = _storage._action {return v}
      return Event_NavigateAction()
    }
    set {_uniqueStorage()._action = .navigateAction(newValue)}
  }

  /// Optional. Indicates that this action occurred in a view that may
  /// not be topmost in the view hierarchy.
  public var hasSuperimposedViews_p: Bool {
    get {return _storage._hasSuperimposedViews_p}
    set {_uniqueStorage()._hasSuperimposedViews_p = newValue}
  }

  /// Optional. Position the the action within its enclosing list.
  public var clientPosition: Event_IndexPath {
    get {return _storage._clientPosition ?? Event_IndexPath()}
    set {_uniqueStorage()._clientPosition = newValue}
  }
  /// Returns true if `clientPosition` has been explicitly set.
  public var hasClientPosition: Bool {return _storage._clientPosition != nil}
  /// Clears the value of `clientPosition`. Subsequent reads from it will return its default value.
  public mutating func clearClientPosition() {_uniqueStorage()._clientPosition = nil}

  /// Optional.  Used for debugging.
  public var idProvenances: Event_IdentifierProvenances {
    get {return _storage._idProvenances ?? Event_IdentifierProvenances()}
    set {_uniqueStorage()._idProvenances = newValue}
  }
  /// Returns true if `idProvenances` has been explicitly set.
  public var hasIDProvenances: Bool {return _storage._idProvenances != nil}
  /// Clears the value of `idProvenances`. Subsequent reads from it will return its default value.
  public mutating func clearIDProvenances() {_uniqueStorage()._idProvenances = nil}

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    case navigateAction(Event_NavigateAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_Action.OneOf_Action, rhs: Event_Action.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.navigateAction, .navigateAction): return {
        guard case .navigateAction(let l) = lhs, case .navigateAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Error from iOS client.
/// Next ID = 5.
public struct Event_IOSError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error code from NSError.
  public var code: Int32 = 0

  /// Error domain from NSError.
  public var domain: String = String()

  /// Description of error.
  public var description_p: String = String()

  /// Which batch generated the error.
  public var batchNumber: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// History of errors from client.
/// Next ID = 3.
public struct Event_ErrorHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Window of latest errors.
  public var iosErrors: [Event_IOSError] = []

  /// Total number of errors encountered.
  public var totalErrors: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Ancestor ID either logged as event or external ID.
/// Next ID = 7.
public struct Event_AncestorIdHistoryItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Changed value of ancestor ID.
  public var ancestorID: String = String()

  /// Event that caused the change, if any.
  public var loggedEvent: Event_AncestorIdHistoryItem.OneOf_LoggedEvent? = nil

  public var userEvent: Event_User {
    get {
      if case .userEvent(let v)? = loggedEvent {return v}
      return Event_User()
    }
    set {loggedEvent = .userEvent(newValue)}
  }

  /// Internally autogenerated session ID.
  public var sessionIDFromUserEvent: String {
    get {
      if case .sessionIDFromUserEvent(let v)? = loggedEvent {return v}
      return String()
    }
    set {loggedEvent = .sessionIDFromUserEvent(newValue)}
  }

  public var viewEvent: Event_View {
    get {
      if case .viewEvent(let v)? = loggedEvent {return v}
      return Event_View()
    }
    set {loggedEvent = .viewEvent(newValue)}
  }

  public var autoViewEvent: Event_AutoView {
    get {
      if case .autoViewEvent(let v)? = loggedEvent {return v}
      return Event_AutoView()
    }
    set {loggedEvent = .autoViewEvent(newValue)}
  }

  /// Which batch number the event was logged in
  public var batchNumber: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Event that caused the change, if any.
  public enum OneOf_LoggedEvent: Equatable {
    case userEvent(Event_User)
    /// Internally autogenerated session ID.
    case sessionIDFromUserEvent(String)
    case viewEvent(Event_View)
    case autoViewEvent(Event_AutoView)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_AncestorIdHistoryItem.OneOf_LoggedEvent, rhs: Event_AncestorIdHistoryItem.OneOf_LoggedEvent) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userEvent, .userEvent): return {
        guard case .userEvent(let l) = lhs, case .userEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionIDFromUserEvent, .sessionIDFromUserEvent): return {
        guard case .sessionIDFromUserEvent(let l) = lhs, case .sessionIDFromUserEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.viewEvent, .viewEvent): return {
        guard case .viewEvent(let l) = lhs, case .viewEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.autoViewEvent, .autoViewEvent): return {
        guard case .autoViewEvent(let l) = lhs, case .autoViewEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// History of ancestor IDs logged by client.
/// Next ID = 9.
public struct Event_AncestorIdHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Window of latest log user ids.
  public var logUserIDHistory: [Event_AncestorIdHistoryItem] = []

  /// Total number of log user ids logged this session.
  public var totalLogUserIdsLogged: Int32 = 0

  /// Window of latest session ids.
  public var sessionIDHistory: [Event_AncestorIdHistoryItem] = []

  /// Total number of session ids logged this session.
  public var totalSessionIdsLogged: Int32 = 0

  /// Window of latest view ids.
  public var viewIDHistory: [Event_AncestorIdHistoryItem] = []

  /// Total number of view ids logged this session.
  public var totalViewIdsLogged: Int32 = 0

  /// Window of latest auto view ids.
  public var autoViewIDHistory: [Event_AncestorIdHistoryItem] = []

  /// Total number of auto view ids logged this session.
  public var totalAutoViewIdsLogged: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Diagnostic information for mobile clients.
/// Next ID = 9.
public struct Event_MobileDiagnostics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for device sending this message.
  public var deviceIdentifier: String = String()

  /// Version identifier for client app.
  public var clientVersion: String = String()

  /// Version of Promoted library.
  public var promotedLibraryVersion: String = String()

  /// Number of batch logs attempted.
  public var batchesAttempted: Int32 = 0

  /// Number of batch logs sent successfully.
  public var batchesSentSuccessfully: Int32 = 0

  /// Number of batch logs that failed to send.
  public var batchesWithErrors: Int32 = 0

  /// Error history.
  public var errorHistory: Event_ErrorHistory {
    get {return _errorHistory ?? Event_ErrorHistory()}
    set {_errorHistory = newValue}
  }
  /// Returns true if `errorHistory` has been explicitly set.
  public var hasErrorHistory: Bool {return self._errorHistory != nil}
  /// Clears the value of `errorHistory`. Subsequent reads from it will return its default value.
  public mutating func clearErrorHistory() {self._errorHistory = nil}

  /// Ancestor ID history. See #133.
  public var ancestorIDHistory: Event_AncestorIdHistory {
    get {return _ancestorIDHistory ?? Event_AncestorIdHistory()}
    set {_ancestorIDHistory = newValue}
  }
  /// Returns true if `ancestorIDHistory` has been explicitly set.
  public var hasAncestorIDHistory: Bool {return self._ancestorIDHistory != nil}
  /// Clears the value of `ancestorIDHistory`. Subsequent reads from it will return its default value.
  public mutating func clearAncestorIDHistory() {self._ancestorIDHistory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorHistory: Event_ErrorHistory? = nil
  fileprivate var _ancestorIDHistory: Event_AncestorIdHistory? = nil
}

/// Wrapper message for all kinds of diagnostic messages.
/// Next ID = 6.
public struct Event_Diagnostics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common fields.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  public var diagnosticsMessage: OneOf_DiagnosticsMessage? {
    get {return _storage._diagnosticsMessage}
    set {_uniqueStorage()._diagnosticsMessage = newValue}
  }

  public var mobileDiagnostics: Event_MobileDiagnostics {
    get {
      if case .mobileDiagnostics(let v)? = _storage._diagnosticsMessage {return v}
      return Event_MobileDiagnostics()
    }
    set {_uniqueStorage()._diagnosticsMessage = .mobileDiagnostics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_DiagnosticsMessage: Equatable {
    case mobileDiagnostics(Event_MobileDiagnostics)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_Diagnostics.OneOf_DiagnosticsMessage, rhs: Event_Diagnostics.OneOf_DiagnosticsMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mobileDiagnostics, .mobileDiagnostics): return {
        guard case .mobileDiagnostics(let l) = lhs, case .mobileDiagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A way to batch up log requests into the same request.
/// Clients can reference logs in different batches.
/// Keep in sync with FlatEvent and FlatResponseInsertion.
/// Next ID = 26.
public struct Event_LogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses the value set on each log record.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  This field is a default user_info to use on all log records
  /// on this LogRequest.  Must be set here or on each child log record.
  /// Clients need to validate that the user_info fields match the actual user.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  This field is a default timing to use on all log records
  /// on this LogRequest.  If neither the log record timing or LogRequest
  /// timing is set, then Promoted's API creates one.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Optional.
  public var clientInfo: Common_ClientInfo {
    get {return _storage._clientInfo ?? Common_ClientInfo()}
    set {_uniqueStorage()._clientInfo = newValue}
  }
  /// Returns true if `clientInfo` has been explicitly set.
  public var hasClientInfo: Bool {return _storage._clientInfo != nil}
  /// Clears the value of `clientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClientInfo() {_uniqueStorage()._clientInfo = nil}

  /// Optional. Information about the user device.
  public var device: Common_Device {
    get {return _storage._device ?? Common_Device()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {_uniqueStorage()._device = nil}

  public var user: [Event_User] {
    get {return _storage._user}
    set {_uniqueStorage()._user = newValue}
  }

  public var cohortMembership: [Event_CohortMembership] {
    get {return _storage._cohortMembership}
    set {_uniqueStorage()._cohortMembership = newValue}
  }

  public var view: [Event_View] {
    get {return _storage._view}
    set {_uniqueStorage()._view = newValue}
  }

  public var autoView: [Event_AutoView] {
    get {return _storage._autoView}
    set {_uniqueStorage()._autoView = newValue}
  }

  public var request: [Delivery_Request] {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  public var insertion: [Delivery_Insertion] {
    get {return _storage._insertion}
    set {_uniqueStorage()._insertion = newValue}
  }

  public var impression: [Event_Impression] {
    get {return _storage._impression}
    set {_uniqueStorage()._impression = newValue}
  }

  public var action: [Event_Action] {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var deliveryLog: [Delivery_DeliveryLog] {
    get {return _storage._deliveryLog}
    set {_uniqueStorage()._deliveryLog = newValue}
  }

  public var diagnostics: [Event_Diagnostics] {
    get {return _storage._diagnostics}
    set {_uniqueStorage()._diagnostics = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "event"

extension Event_IdentifierProvenance: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NULL"),
    2: .same(proto: "EMPTY"),
    3: .same(proto: "AUTOGENERATED"),
    4: .same(proto: "PLATFORM_SPECIFIED"),
  ]
}

extension Event_CohortArm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_GROUP"),
    1: .same(proto: "CONTROL"),
    2: .same(proto: "TREATMENT"),
    3: .same(proto: "TREATMENT1"),
    4: .same(proto: "TREATMENT2"),
    5: .same(proto: "TREATMENT3"),
  ]
}

extension Event_ImpressionSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_IMPRESSION_SOURCE_TYPE"),
    1: .same(proto: "DELIVERY"),
    2: .same(proto: "CLIENT_BACKEND"),
  ]
}

extension Event_ActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTION_TYPE"),
    1: .same(proto: "CUSTOM_ACTION_TYPE"),
    2: .same(proto: "NAVIGATE"),
    3: .same(proto: "PURCHASE"),
    4: .same(proto: "ADD_TO_CART"),
    5: .same(proto: "SHARE"),
    6: .same(proto: "LIKE"),
    7: .same(proto: "COMMENT"),
    8: .same(proto: "CHECKOUT"),
    9: .same(proto: "UNLIKE"),
    10: .same(proto: "REMOVE_FROM_CART"),
    11: .same(proto: "MAKE_OFFER"),
    12: .same(proto: "ASK_QUESTION"),
    13: .same(proto: "ANSWER_QUESTION"),
    14: .same(proto: "COMPLETE_SIGN_IN"),
    15: .same(proto: "COMPLETE_SIGN_UP"),
  ]
}

extension Event_JoinedIdentifiers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinedIdentifiers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "session_id"),
    5: .standard(proto: "view_id"),
    9: .standard(proto: "auto_view_id"),
    6: .standard(proto: "request_id"),
    7: .standard(proto: "insertion_id"),
    8: .standard(proto: "impression_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.autoViewID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 7)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 8)
    }
    if !self.autoViewID.isEmpty {
      try visitor.visitSingularStringField(value: self.autoViewID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_JoinedIdentifiers, rhs: Event_JoinedIdentifiers) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.autoViewID != rhs.autoViewID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_IdentifierProvenances: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentifierProvenances"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id_provenance"),
    9: .standard(proto: "log_user_id_provenance"),
    2: .standard(proto: "session_id_provenance"),
    3: .standard(proto: "view_id_provenance"),
    8: .standard(proto: "auto_view_id_provenance"),
    10: .standard(proto: "insertion_id_provenance"),
    4: .standard(proto: "impression_id_provenance"),
    5: .standard(proto: "action_id_provenance"),
    6: .standard(proto: "content_id_provenance"),
    7: .standard(proto: "request_id_provenance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.userIDProvenance) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sessionIDProvenance) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.viewIDProvenance) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.impressionIDProvenance) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.actionIDProvenance) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.contentIDProvenance) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.requestIDProvenance) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.autoViewIDProvenance) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.logUserIDProvenance) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.insertionIDProvenance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.userIDProvenance, fieldNumber: 1)
    }
    if self.sessionIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.sessionIDProvenance, fieldNumber: 2)
    }
    if self.viewIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.viewIDProvenance, fieldNumber: 3)
    }
    if self.impressionIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.impressionIDProvenance, fieldNumber: 4)
    }
    if self.actionIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.actionIDProvenance, fieldNumber: 5)
    }
    if self.contentIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.contentIDProvenance, fieldNumber: 6)
    }
    if self.requestIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.requestIDProvenance, fieldNumber: 7)
    }
    if self.autoViewIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.autoViewIDProvenance, fieldNumber: 8)
    }
    if self.logUserIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.logUserIDProvenance, fieldNumber: 9)
    }
    if self.insertionIDProvenance != .unknown {
      try visitor.visitSingularEnumField(value: self.insertionIDProvenance, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_IdentifierProvenances, rhs: Event_IdentifierProvenances) -> Bool {
    if lhs.userIDProvenance != rhs.userIDProvenance {return false}
    if lhs.logUserIDProvenance != rhs.logUserIDProvenance {return false}
    if lhs.sessionIDProvenance != rhs.sessionIDProvenance {return false}
    if lhs.viewIDProvenance != rhs.viewIDProvenance {return false}
    if lhs.autoViewIDProvenance != rhs.autoViewIDProvenance {return false}
    if lhs.insertionIDProvenance != rhs.insertionIDProvenance {return false}
    if lhs.impressionIDProvenance != rhs.impressionIDProvenance {return false}
    if lhs.actionIDProvenance != rhs.actionIDProvenance {return false}
    if lhs.contentIDProvenance != rhs.contentIDProvenance {return false}
    if lhs.requestIDProvenance != rhs.requestIDProvenance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    7: .standard(proto: "id_provenances"),
    6: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _idProvenances: Event_IdentifierProvenances? = nil
    var _properties: Common_Properties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _idProvenances = source._idProvenances
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._idProvenances) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._idProvenances {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_User, rhs: Event_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._idProvenances != rhs_storage._idProvenances {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_CohortMembership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CohortMembership"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "membership_id"),
    8: .standard(proto: "cohort_id"),
    9: .same(proto: "arm"),
    10: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientInfo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.membershipID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cohortID) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.arm) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._clientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.membershipID.isEmpty {
      try visitor.visitSingularStringField(value: self.membershipID, fieldNumber: 6)
    }
    if !self.cohortID.isEmpty {
      try visitor.visitSingularStringField(value: self.cohortID, fieldNumber: 8)
    }
    if self.arm != .unknownGroup {
      try visitor.visitSingularEnumField(value: self.arm, fieldNumber: 9)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_CohortMembership, rhs: Event_CohortMembership) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs._clientInfo != rhs._clientInfo {return false}
    if lhs.membershipID != rhs.membershipID {return false}
    if lhs.cohortID != rhs.cohortID {return false}
    if lhs.arm != rhs.arm {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_WebPageView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebPageView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    3: .same(proto: "referrer"),
    4: .standard(proto: "document_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.referrer) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._documentSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.referrer.isEmpty {
      try visitor.visitSingularStringField(value: self.referrer, fieldNumber: 3)
    }
    if let v = self._documentSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_WebPageView, rhs: Event_WebPageView) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.referrer != rhs.referrer {return false}
    if lhs._documentSize != rhs._documentSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_AppScreenView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppScreenView"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AppScreenView, rhs: Event_AppScreenView) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".View"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "view_id"),
    17: .standard(proto: "auto_view_id"),
    7: .standard(proto: "session_id"),
    8: .same(proto: "name"),
    9: .standard(proto: "use_case"),
    10: .standard(proto: "search_query"),
    11: .same(proto: "properties"),
    16: .same(proto: "locale"),
    13: .standard(proto: "view_type"),
    14: .standard(proto: "web_page_view"),
    15: .standard(proto: "app_screen_view"),
    18: .standard(proto: "id_provenances"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _viewID: String = String()
    var _autoViewID: String = String()
    var _sessionID: String = String()
    var _name: String = String()
    var _useCase: Delivery_UseCase = .unknownUseCase
    var _searchQuery: String = String()
    var _properties: Common_Properties? = nil
    var _locale: Common_Locale? = nil
    var _viewType: Event_View.ViewType = .unknownViewType
    var _uiType: Event_View.OneOf_UiType?
    var _idProvenances: Event_IdentifierProvenances? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _viewID = source._viewID
      _autoViewID = source._autoViewID
      _sessionID = source._sessionID
      _name = source._name
      _useCase = source._useCase
      _searchQuery = source._searchQuery
      _properties = source._properties
      _locale = source._locale
      _viewType = source._viewType
      _uiType = source._uiType
      _idProvenances = source._idProvenances
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._useCase) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._searchQuery) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._viewType) }()
        case 14: try {
          var v: Event_WebPageView?
          var hadOneofValue = false
          if let current = _storage._uiType {
            hadOneofValue = true
            if case .webPageView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._uiType = .webPageView(v)
          }
        }()
        case 15: try {
          var v: Event_AppScreenView?
          var hadOneofValue = false
          if let current = _storage._uiType {
            hadOneofValue = true
            if case .appScreenView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._uiType = .appScreenView(v)
          }
        }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._locale) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._autoViewID) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._idProvenances) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 6)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 7)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      if _storage._useCase != .unknownUseCase {
        try visitor.visitSingularEnumField(value: _storage._useCase, fieldNumber: 9)
      }
      if !_storage._searchQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._searchQuery, fieldNumber: 10)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._viewType != .unknownViewType {
        try visitor.visitSingularEnumField(value: _storage._viewType, fieldNumber: 13)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._uiType {
      case .webPageView?: try {
        guard case .webPageView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .appScreenView?: try {
        guard case .appScreenView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case nil: break
      }
      if let v = _storage._locale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._autoViewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._autoViewID, fieldNumber: 17)
      }
      if let v = _storage._idProvenances {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_View, rhs: Event_View) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._autoViewID != rhs_storage._autoViewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._useCase != rhs_storage._useCase {return false}
        if _storage._searchQuery != rhs_storage._searchQuery {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._viewType != rhs_storage._viewType {return false}
        if _storage._uiType != rhs_storage._uiType {return false}
        if _storage._idProvenances != rhs_storage._idProvenances {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View.ViewType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VIEW_TYPE"),
    1: .same(proto: "WEB_PAGE"),
    2: .same(proto: "APP_SCREEN"),
  ]
}

extension Event_AutoView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutoView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "auto_view_id"),
    14: .standard(proto: "view_id"),
    7: .standard(proto: "session_id"),
    8: .same(proto: "name"),
    9: .standard(proto: "use_case"),
    10: .same(proto: "properties"),
    11: .same(proto: "locale"),
    12: .standard(proto: "web_page_view"),
    13: .standard(proto: "app_screen_view"),
    15: .standard(proto: "id_provenances"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _autoViewID: String = String()
    var _viewID: String = String()
    var _sessionID: String = String()
    var _name: String = String()
    var _useCase: Delivery_UseCase = .unknownUseCase
    var _properties: Common_Properties? = nil
    var _locale: Common_Locale? = nil
    var _uiType: Event_AutoView.OneOf_UiType?
    var _idProvenances: Event_IdentifierProvenances? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _autoViewID = source._autoViewID
      _viewID = source._viewID
      _sessionID = source._sessionID
      _name = source._name
      _useCase = source._useCase
      _properties = source._properties
      _locale = source._locale
      _uiType = source._uiType
      _idProvenances = source._idProvenances
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._autoViewID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._useCase) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._locale) }()
        case 12: try {
          var v: Event_WebPageView?
          var hadOneofValue = false
          if let current = _storage._uiType {
            hadOneofValue = true
            if case .webPageView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._uiType = .webPageView(v)
          }
        }()
        case 13: try {
          var v: Event_AppScreenView?
          var hadOneofValue = false
          if let current = _storage._uiType {
            hadOneofValue = true
            if case .appScreenView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._uiType = .appScreenView(v)
          }
        }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._idProvenances) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._autoViewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._autoViewID, fieldNumber: 6)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 7)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      if _storage._useCase != .unknownUseCase {
        try visitor.visitSingularEnumField(value: _storage._useCase, fieldNumber: 9)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._locale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._uiType {
      case .webPageView?: try {
        guard case .webPageView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .appScreenView?: try {
        guard case .appScreenView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case nil: break
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 14)
      }
      if let v = _storage._idProvenances {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AutoView, rhs: Event_AutoView) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._autoViewID != rhs_storage._autoViewID {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._useCase != rhs_storage._useCase {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._uiType != rhs_storage._uiType {return false}
        if _storage._idProvenances != rhs_storage._idProvenances {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_IndexPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.index.isEmpty {
      try visitor.visitPackedInt32Field(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_IndexPath, rhs: Event_IndexPath) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Impression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Impression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "impression_id"),
    7: .standard(proto: "insertion_id"),
    8: .standard(proto: "request_id"),
    10: .standard(proto: "view_id"),
    15: .standard(proto: "auto_view_id"),
    9: .standard(proto: "session_id"),
    12: .standard(proto: "content_id"),
    13: .standard(proto: "source_type"),
    14: .standard(proto: "has_superimposed_views"),
    16: .standard(proto: "client_position"),
    17: .standard(proto: "id_provenances"),
    11: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _impressionID: String = String()
    var _insertionID: String = String()
    var _requestID: String = String()
    var _viewID: String = String()
    var _autoViewID: String = String()
    var _sessionID: String = String()
    var _contentID: String = String()
    var _sourceType: Event_ImpressionSourceType = .unknownImpressionSourceType
    var _hasSuperimposedViews_p: Bool = false
    var _clientPosition: Event_IndexPath? = nil
    var _idProvenances: Event_IdentifierProvenances? = nil
    var _properties: Common_Properties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _impressionID = source._impressionID
      _insertionID = source._insertionID
      _requestID = source._requestID
      _viewID = source._viewID
      _autoViewID = source._autoViewID
      _sessionID = source._sessionID
      _contentID = source._contentID
      _sourceType = source._sourceType
      _hasSuperimposedViews_p = source._hasSuperimposedViews_p
      _clientPosition = source._clientPosition
      _idProvenances = source._idProvenances
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._impressionID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._insertionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._contentID) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._sourceType) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._hasSuperimposedViews_p) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._autoViewID) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._clientPosition) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._idProvenances) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._impressionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._impressionID, fieldNumber: 6)
      }
      if !_storage._insertionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._insertionID, fieldNumber: 7)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 8)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 9)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 10)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._contentID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentID, fieldNumber: 12)
      }
      if _storage._sourceType != .unknownImpressionSourceType {
        try visitor.visitSingularEnumField(value: _storage._sourceType, fieldNumber: 13)
      }
      if _storage._hasSuperimposedViews_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSuperimposedViews_p, fieldNumber: 14)
      }
      if !_storage._autoViewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._autoViewID, fieldNumber: 15)
      }
      if let v = _storage._clientPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._idProvenances {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Impression, rhs: Event_Impression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._impressionID != rhs_storage._impressionID {return false}
        if _storage._insertionID != rhs_storage._insertionID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._autoViewID != rhs_storage._autoViewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._contentID != rhs_storage._contentID {return false}
        if _storage._sourceType != rhs_storage._sourceType {return false}
        if _storage._hasSuperimposedViews_p != rhs_storage._hasSuperimposedViews_p {return false}
        if _storage._clientPosition != rhs_storage._clientPosition {return false}
        if _storage._idProvenances != rhs_storage._idProvenances {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_NavigateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigateAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetURL.isEmpty {
      try visitor.visitSingularStringField(value: self.targetURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_NavigateAction, rhs: Event_NavigateAction) -> Bool {
    if lhs.targetURL != rhs.targetURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    6: .standard(proto: "action_id"),
    7: .standard(proto: "impression_id"),
    8: .standard(proto: "insertion_id"),
    9: .standard(proto: "request_id"),
    11: .standard(proto: "view_id"),
    23: .standard(proto: "auto_view_id"),
    10: .standard(proto: "session_id"),
    21: .standard(proto: "content_id"),
    12: .same(proto: "name"),
    14: .standard(proto: "action_type"),
    15: .standard(proto: "custom_action_type"),
    17: .standard(proto: "element_id"),
    18: .standard(proto: "navigate_action"),
    22: .standard(proto: "has_superimposed_views"),
    24: .standard(proto: "client_position"),
    25: .standard(proto: "id_provenances"),
    20: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _actionID: String = String()
    var _impressionID: String = String()
    var _insertionID: String = String()
    var _requestID: String = String()
    var _viewID: String = String()
    var _autoViewID: String = String()
    var _sessionID: String = String()
    var _contentID: String = String()
    var _name: String = String()
    var _actionType: Event_ActionType = .unknownActionType
    var _customActionType: String = String()
    var _elementID: String = String()
    var _action: Event_Action.OneOf_Action?
    var _hasSuperimposedViews_p: Bool = false
    var _clientPosition: Event_IndexPath? = nil
    var _idProvenances: Event_IdentifierProvenances? = nil
    var _properties: Common_Properties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _actionID = source._actionID
      _impressionID = source._impressionID
      _insertionID = source._insertionID
      _requestID = source._requestID
      _viewID = source._viewID
      _autoViewID = source._autoViewID
      _sessionID = source._sessionID
      _contentID = source._contentID
      _name = source._name
      _actionType = source._actionType
      _customActionType = source._customActionType
      _elementID = source._elementID
      _action = source._action
      _hasSuperimposedViews_p = source._hasSuperimposedViews_p
      _clientPosition = source._clientPosition
      _idProvenances = source._idProvenances
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._actionID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._impressionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._insertionID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._actionType) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._customActionType) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._elementID) }()
        case 18: try {
          var v: Event_NavigateAction?
          var hadOneofValue = false
          if let current = _storage._action {
            hadOneofValue = true
            if case .navigateAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._action = .navigateAction(v)
          }
        }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._contentID) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._hasSuperimposedViews_p) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._autoViewID) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._clientPosition) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._idProvenances) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._actionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionID, fieldNumber: 6)
      }
      if !_storage._impressionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._impressionID, fieldNumber: 7)
      }
      if !_storage._insertionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._insertionID, fieldNumber: 8)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 9)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 10)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 11)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 12)
      }
      if _storage._actionType != .unknownActionType {
        try visitor.visitSingularEnumField(value: _storage._actionType, fieldNumber: 14)
      }
      if !_storage._customActionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customActionType, fieldNumber: 15)
      }
      if !_storage._elementID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._elementID, fieldNumber: 17)
      }
      if case .navigateAction(let v)? = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._contentID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentID, fieldNumber: 21)
      }
      if _storage._hasSuperimposedViews_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSuperimposedViews_p, fieldNumber: 22)
      }
      if !_storage._autoViewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._autoViewID, fieldNumber: 23)
      }
      if let v = _storage._clientPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._idProvenances {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Action, rhs: Event_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._actionID != rhs_storage._actionID {return false}
        if _storage._impressionID != rhs_storage._impressionID {return false}
        if _storage._insertionID != rhs_storage._insertionID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._autoViewID != rhs_storage._autoViewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._contentID != rhs_storage._contentID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._actionType != rhs_storage._actionType {return false}
        if _storage._customActionType != rhs_storage._customActionType {return false}
        if _storage._elementID != rhs_storage._elementID {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._hasSuperimposedViews_p != rhs_storage._hasSuperimposedViews_p {return false}
        if _storage._clientPosition != rhs_storage._clientPosition {return false}
        if _storage._idProvenances != rhs_storage._idProvenances {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_IOSError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IOSError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "domain"),
    3: .same(proto: "description"),
    4: .standard(proto: "batch_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.batchNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.batchNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.batchNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_IOSError, rhs: Event_IOSError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.batchNumber != rhs.batchNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ErrorHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ios_errors"),
    2: .standard(proto: "total_errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.iosErrors) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalErrors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.iosErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iosErrors, fieldNumber: 1)
    }
    if self.totalErrors != 0 {
      try visitor.visitSingularInt32Field(value: self.totalErrors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ErrorHistory, rhs: Event_ErrorHistory) -> Bool {
    if lhs.iosErrors != rhs.iosErrors {return false}
    if lhs.totalErrors != rhs.totalErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_AncestorIdHistoryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AncestorIdHistoryItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ancestor_id"),
    2: .standard(proto: "user_event"),
    3: .standard(proto: "session_id_from_user_event"),
    4: .standard(proto: "view_event"),
    6: .standard(proto: "auto_view_event"),
    5: .standard(proto: "batch_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ancestorID) }()
      case 2: try {
        var v: Event_User?
        var hadOneofValue = false
        if let current = self.loggedEvent {
          hadOneofValue = true
          if case .userEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.loggedEvent = .userEvent(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.loggedEvent != nil {try decoder.handleConflictingOneOf()}
          self.loggedEvent = .sessionIDFromUserEvent(v)
        }
      }()
      case 4: try {
        var v: Event_View?
        var hadOneofValue = false
        if let current = self.loggedEvent {
          hadOneofValue = true
          if case .viewEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.loggedEvent = .viewEvent(v)
        }
      }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.batchNumber) }()
      case 6: try {
        var v: Event_AutoView?
        var hadOneofValue = false
        if let current = self.loggedEvent {
          hadOneofValue = true
          if case .autoViewEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.loggedEvent = .autoViewEvent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ancestorID.isEmpty {
      try visitor.visitSingularStringField(value: self.ancestorID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.loggedEvent {
    case .userEvent?: try {
      guard case .userEvent(let v)? = self.loggedEvent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sessionIDFromUserEvent?: try {
      guard case .sessionIDFromUserEvent(let v)? = self.loggedEvent else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .viewEvent?: try {
      guard case .viewEvent(let v)? = self.loggedEvent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    if self.batchNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.batchNumber, fieldNumber: 5)
    }
    if case .autoViewEvent(let v)? = self.loggedEvent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AncestorIdHistoryItem, rhs: Event_AncestorIdHistoryItem) -> Bool {
    if lhs.ancestorID != rhs.ancestorID {return false}
    if lhs.loggedEvent != rhs.loggedEvent {return false}
    if lhs.batchNumber != rhs.batchNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_AncestorIdHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AncestorIdHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_user_id_history"),
    2: .standard(proto: "total_log_user_ids_logged"),
    3: .standard(proto: "session_id_history"),
    4: .standard(proto: "total_session_ids_logged"),
    5: .standard(proto: "view_id_history"),
    6: .standard(proto: "total_view_ids_logged"),
    7: .standard(proto: "auto_view_id_history"),
    8: .standard(proto: "total_auto_view_ids_logged"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logUserIDHistory) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalLogUserIdsLogged) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sessionIDHistory) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalSessionIdsLogged) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.viewIDHistory) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.totalViewIdsLogged) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.autoViewIDHistory) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.totalAutoViewIdsLogged) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logUserIDHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logUserIDHistory, fieldNumber: 1)
    }
    if self.totalLogUserIdsLogged != 0 {
      try visitor.visitSingularInt32Field(value: self.totalLogUserIdsLogged, fieldNumber: 2)
    }
    if !self.sessionIDHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionIDHistory, fieldNumber: 3)
    }
    if self.totalSessionIdsLogged != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSessionIdsLogged, fieldNumber: 4)
    }
    if !self.viewIDHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.viewIDHistory, fieldNumber: 5)
    }
    if self.totalViewIdsLogged != 0 {
      try visitor.visitSingularInt32Field(value: self.totalViewIdsLogged, fieldNumber: 6)
    }
    if !self.autoViewIDHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.autoViewIDHistory, fieldNumber: 7)
    }
    if self.totalAutoViewIdsLogged != 0 {
      try visitor.visitSingularInt32Field(value: self.totalAutoViewIdsLogged, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AncestorIdHistory, rhs: Event_AncestorIdHistory) -> Bool {
    if lhs.logUserIDHistory != rhs.logUserIDHistory {return false}
    if lhs.totalLogUserIdsLogged != rhs.totalLogUserIdsLogged {return false}
    if lhs.sessionIDHistory != rhs.sessionIDHistory {return false}
    if lhs.totalSessionIdsLogged != rhs.totalSessionIdsLogged {return false}
    if lhs.viewIDHistory != rhs.viewIDHistory {return false}
    if lhs.totalViewIdsLogged != rhs.totalViewIdsLogged {return false}
    if lhs.autoViewIDHistory != rhs.autoViewIDHistory {return false}
    if lhs.totalAutoViewIdsLogged != rhs.totalAutoViewIdsLogged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_MobileDiagnostics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileDiagnostics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_identifier"),
    2: .standard(proto: "client_version"),
    3: .standard(proto: "promoted_library_version"),
    4: .standard(proto: "batches_attempted"),
    5: .standard(proto: "batches_sent_successfully"),
    6: .standard(proto: "batches_with_errors"),
    7: .standard(proto: "error_history"),
    8: .standard(proto: "ancestor_id_history"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.promotedLibraryVersion) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.batchesAttempted) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.batchesSentSuccessfully) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.batchesWithErrors) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._errorHistory) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._ancestorIDHistory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceIdentifier, fieldNumber: 1)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 2)
    }
    if !self.promotedLibraryVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.promotedLibraryVersion, fieldNumber: 3)
    }
    if self.batchesAttempted != 0 {
      try visitor.visitSingularInt32Field(value: self.batchesAttempted, fieldNumber: 4)
    }
    if self.batchesSentSuccessfully != 0 {
      try visitor.visitSingularInt32Field(value: self.batchesSentSuccessfully, fieldNumber: 5)
    }
    if self.batchesWithErrors != 0 {
      try visitor.visitSingularInt32Field(value: self.batchesWithErrors, fieldNumber: 6)
    }
    if let v = self._errorHistory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._ancestorIDHistory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_MobileDiagnostics, rhs: Event_MobileDiagnostics) -> Bool {
    if lhs.deviceIdentifier != rhs.deviceIdentifier {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.promotedLibraryVersion != rhs.promotedLibraryVersion {return false}
    if lhs.batchesAttempted != rhs.batchesAttempted {return false}
    if lhs.batchesSentSuccessfully != rhs.batchesSentSuccessfully {return false}
    if lhs.batchesWithErrors != rhs.batchesWithErrors {return false}
    if lhs._errorHistory != rhs._errorHistory {return false}
    if lhs._ancestorIDHistory != rhs._ancestorIDHistory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Diagnostics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Diagnostics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    5: .standard(proto: "mobile_diagnostics"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _diagnosticsMessage: Event_Diagnostics.OneOf_DiagnosticsMessage?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _diagnosticsMessage = source._diagnosticsMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 5: try {
          var v: Event_MobileDiagnostics?
          var hadOneofValue = false
          if let current = _storage._diagnosticsMessage {
            hadOneofValue = true
            if case .mobileDiagnostics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._diagnosticsMessage = .mobileDiagnostics(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if case .mobileDiagnostics(let v)? = _storage._diagnosticsMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Diagnostics, rhs: Event_Diagnostics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._diagnosticsMessage != rhs_storage._diagnosticsMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    4: .standard(proto: "client_info"),
    24: .same(proto: "device"),
    7: .same(proto: "user"),
    8: .standard(proto: "cohort_membership"),
    11: .same(proto: "view"),
    25: .standard(proto: "auto_view"),
    12: .same(proto: "request"),
    13: .same(proto: "insertion"),
    14: .same(proto: "impression"),
    15: .same(proto: "action"),
    18: .standard(proto: "delivery_log"),
    23: .same(proto: "diagnostics"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _clientInfo: Common_ClientInfo? = nil
    var _device: Common_Device? = nil
    var _user: [Event_User] = []
    var _cohortMembership: [Event_CohortMembership] = []
    var _view: [Event_View] = []
    var _autoView: [Event_AutoView] = []
    var _request: [Delivery_Request] = []
    var _insertion: [Delivery_Insertion] = []
    var _impression: [Event_Impression] = []
    var _action: [Event_Action] = []
    var _deliveryLog: [Delivery_DeliveryLog] = []
    var _diagnostics: [Event_Diagnostics] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _clientInfo = source._clientInfo
      _device = source._device
      _user = source._user
      _cohortMembership = source._cohortMembership
      _view = source._view
      _autoView = source._autoView
      _request = source._request
      _insertion = source._insertion
      _impression = source._impression
      _action = source._action
      _deliveryLog = source._deliveryLog
      _diagnostics = source._diagnostics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientInfo) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._user) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._cohortMembership) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._view) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._request) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._insertion) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._impression) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._action) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._deliveryLog) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._diagnostics) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._autoView) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._user.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._user, fieldNumber: 7)
      }
      if !_storage._cohortMembership.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cohortMembership, fieldNumber: 8)
      }
      if !_storage._view.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._view, fieldNumber: 11)
      }
      if !_storage._request.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._request, fieldNumber: 12)
      }
      if !_storage._insertion.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._insertion, fieldNumber: 13)
      }
      if !_storage._impression.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._impression, fieldNumber: 14)
      }
      if !_storage._action.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._action, fieldNumber: 15)
      }
      if !_storage._deliveryLog.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deliveryLog, fieldNumber: 18)
      }
      if !_storage._diagnostics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._diagnostics, fieldNumber: 23)
      }
      if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if !_storage._autoView.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._autoView, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LogRequest, rhs: Event_LogRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._cohortMembership != rhs_storage._cohortMembership {return false}
        if _storage._view != rhs_storage._view {return false}
        if _storage._autoView != rhs_storage._autoView {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._insertion != rhs_storage._insertion {return false}
        if _storage._impression != rhs_storage._impression {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._deliveryLog != rhs_storage._deliveryLog {return false}
        if _storage._diagnostics != rhs_storage._diagnostics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
