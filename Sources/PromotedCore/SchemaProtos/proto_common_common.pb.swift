// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/common/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Next ID = 21.
public enum Common_CurrencyCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownCurrencyCode // = 0
  case usd // = 1
  case eur // = 2
  case jpy // = 3
  case gbp // = 4
  case aud // = 5
  case cad // = 6
  case chf // = 7
  case cny // = 8
  case hkd // = 9
  case nzd // = 10
  case sek // = 11
  case krw // = 12
  case sgd // = 13
  case nok // = 14
  case mxn // = 15
  case inr // = 16
  case rub // = 17
  case zar // = 18
  case `try` // = 19
  case brl // = 20
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownCurrencyCode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownCurrencyCode
    case 1: self = .usd
    case 2: self = .eur
    case 3: self = .jpy
    case 4: self = .gbp
    case 5: self = .aud
    case 6: self = .cad
    case 7: self = .chf
    case 8: self = .cny
    case 9: self = .hkd
    case 10: self = .nzd
    case 11: self = .sek
    case 12: self = .krw
    case 13: self = .sgd
    case 14: self = .nok
    case 15: self = .mxn
    case 16: self = .inr
    case 17: self = .rub
    case 18: self = .zar
    case 19: self = .try
    case 20: self = .brl
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownCurrencyCode: return 0
    case .usd: return 1
    case .eur: return 2
    case .jpy: return 3
    case .gbp: return 4
    case .aud: return 5
    case .cad: return 6
    case .chf: return 7
    case .cny: return 8
    case .hkd: return 9
    case .nzd: return 10
    case .sek: return 11
    case .krw: return 12
    case .sgd: return 13
    case .nok: return 14
    case .mxn: return 15
    case .inr: return 16
    case .rub: return 17
    case .zar: return 18
    case .try: return 19
    case .brl: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_CurrencyCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Common_CurrencyCode] = [
    .unknownCurrencyCode,
    .usd,
    .eur,
    .jpy,
    .gbp,
    .aud,
    .cad,
    .chf,
    .cny,
    .hkd,
    .nzd,
    .sek,
    .krw,
    .sgd,
    .nok,
    .mxn,
    .inr,
    .rub,
    .zar,
    .try,
    .brl,
  ]
}

#endif  // swift(>=4.2)

/// Next ID = 4.
public enum Common_DeviceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownDeviceType // = 0
  case desktop // = 1
  case mobile // = 2
  case tablet // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownDeviceType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDeviceType
    case 1: self = .desktop
    case 2: self = .mobile
    case 3: self = .tablet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownDeviceType: return 0
    case .desktop: return 1
    case .mobile: return 2
    case .tablet: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_DeviceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Common_DeviceType] = [
    .unknownDeviceType,
    .desktop,
    .mobile,
    .tablet,
  ]
}

#endif  // swift(>=4.2)

/// Next ID = 7.
public struct Common_EntityPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformID: UInt64 = 0

  public var customerID: UInt64 = 0

  public var accountID: UInt64 = 0

  public var campaignID: UInt64 = 0

  public var promotionID: UInt64 = 0

  public var contentID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a money value.  e.g. $1 USD.
/// Next ID = 3.
public struct Common_Money {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var currencyCode: Common_CurrencyCode = .unknownCurrencyCode

  /// 1 million = 1 denomination in the currency.  E.g. 1 USD = 1,000,000 price_micros_per_unit.
  /// We use micros to avoid double aggregation errors.
  public var amountMicros: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Common submessage that scopes helps scope a request/log to a user.
///
/// Next ID = 5.
public struct Common_UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  The Platform's actual user ID.
  /// This field will be cleared from our transaction logs.
  public var userID: String = String()

  /// Optional.  This is a user UUID that is different from user_id and
  /// can quickly be disassociated from the actual user ID.  This is useful:
  /// 1. in case the user wants to be forgotten.
  /// 2. logging unauthenticated users.
  /// The user UUID is in a different ID space than user_id.
  public var anonUserID: String = String()

  /// Optional, defaults to false. Indicates that the user is from the
  /// marketplace or Promoted team.
  public var isInternalUser: Bool = false

  /// Optional, defaults to false.  Can be used to suppress traffic.
  /// One use case is to use this field when debugging specific customer
  /// experiences by overriding the anon_user_id.
  public var ignoreUsage: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Info about the client.
/// Next ID = 3.
public struct Common_ClientInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientType: Common_ClientInfo.ClientType = .unknownRequestClient

  public var trafficType: Common_ClientInfo.TrafficType = .unknownTrafficType

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Next ID = 5;
  public enum ClientType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownRequestClient // = 0

    /// Your (customer) server.
    case platformServer // = 1

    /// Your (customer) client.
    case platformClient // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownRequestClient
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownRequestClient
      case 1: self = .platformServer
      case 2: self = .platformClient
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownRequestClient: return 0
      case .platformServer: return 1
      case .platformClient: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Used to indicate the type of traffic.  We can use this to prioritize resources.
  /// Next ID = 6.
  public enum TrafficType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownTrafficType // = 0

    /// Live traffic.
    case production // = 1

    /// Replayed traffic.  We'd like similar to PRODUCTION level.
    case replay // = 2

    /// Shadow traffic to delivery during logging.
    case shadow // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownTrafficType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownTrafficType
      case 1: self = .production
      case 2: self = .replay
      case 4: self = .shadow
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownTrafficType: return 0
      case .production: return 1
      case .replay: return 2
      case .shadow: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Common_ClientInfo.ClientType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Common_ClientInfo.ClientType] = [
    .unknownRequestClient,
    .platformServer,
    .platformClient,
  ]
}

extension Common_ClientInfo.TrafficType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Common_ClientInfo.TrafficType] = [
    .unknownTrafficType,
    .production,
    .replay,
    .shadow,
  ]
}

#endif  // swift(>=4.2)

/// Locale for session
/// Next ID = 3.
public struct Common_Locale {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CodeReview - Which ISO code is this?  ISO 639-1? 2? 3?
  /// "en", "zh_Hant", "fr"
  public var languageCode: String = String()

  /// CodeReview - Which ISO code?  ISO 3166-1?
  /// "US", "CA", "FR"
  public var regionCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Rectangle size in pixels
/// Next ID = 3.
public struct Common_Size {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: UInt32 = 0

  public var height: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device screen
/// Next ID = 3.
public struct Common_Screen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Android: DisplayMetrics.widthPixels/heightPixels
  /// iOS: UIScreen.nativeBounds.width/height
  public var size: Common_Size {
    get {return _size ?? Common_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  /// Natural scale factor.
  /// Android: DisplayMetrics.density
  /// iOS: UIScreen.scale
  public var scale: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _size: Common_Size? = nil
}

/// A sub-message containing Device info.
/// Next ID = 13.
public struct Common_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceType: Common_DeviceType {
    get {return _storage._deviceType}
    set {_uniqueStorage()._deviceType = newValue}
  }

  /// Android: android.os.Build.BRAND
  ///          (eg. "google", "verizon", "tmobile", "Samsung")
  /// iOS: "Apple"
  public var brand: String {
    get {return _storage._brand}
    set {_uniqueStorage()._brand = newValue}
  }

  /// Android: android.os.Build.MANUFACTURER
  ///          (eg. "HTC", "Motorola", "HUAWEI")
  /// iOS: "Apple"
  public var manufacturer: String {
    get {return _storage._manufacturer}
    set {_uniqueStorage()._manufacturer = newValue}
  }

  /// Android: android.os.Build.MODEL
  ///          (eg. "GT-S5830L", "MB860")
  /// iOS: "iPhoneXX,YY" or "iPadXX,YY"
  public var identifier: String {
    get {return _storage._identifier}
    set {_uniqueStorage()._identifier = newValue}
  }

  /// Android: android.os.Build.VERSION.RELEASE
  /// iOS: "14.4.1"
  public var osVersion: String {
    get {return _storage._osVersion}
    set {_uniqueStorage()._osVersion = newValue}
  }

  /// Deprecated.
  public var locale: Common_Locale {
    get {return _storage._locale ?? Common_Locale()}
    set {_uniqueStorage()._locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return _storage._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {_uniqueStorage()._locale = nil}

  public var screen: Common_Screen {
    get {return _storage._screen ?? Common_Screen()}
    set {_uniqueStorage()._screen = newValue}
  }
  /// Returns true if `screen` has been explicitly set.
  public var hasScreen: Bool {return _storage._screen != nil}
  /// Clears the value of `screen`. Subsequent reads from it will return its default value.
  public mutating func clearScreen() {_uniqueStorage()._screen = nil}

  /// Optional.  We'll use IP Address to guess the user's
  /// location when necessary and possible on desktop.
  /// Most likely in a server integration this should be the value
  /// of the X-Forwarded-For header.
  public var ipAddress: String {
    get {return _storage._ipAddress}
    set {_uniqueStorage()._ipAddress = newValue}
  }

  /// Optional. User device's actual geolocation if available.
  public var location: Common_Location {
    get {return _storage._location ?? Common_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// Optional. Information about the user's web client (on web or mobile browser).
  public var browser: Common_Browser {
    get {return _storage._browser ?? Common_Browser()}
    set {_uniqueStorage()._browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return _storage._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {_uniqueStorage()._browser = nil}

  /// Optional. Version string for platform app.
  public var platformAppVersion: String {
    get {return _storage._platformAppVersion}
    set {_uniqueStorage()._platformAppVersion = newValue}
  }

  /// Optional. Version string for mobile SDK.
  public var promotedMobileSdkVersion: String {
    get {return _storage._promotedMobileSdkVersion}
    set {_uniqueStorage()._promotedMobileSdkVersion = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// A newer alternative to user agent strings.
/// Next ID = 8.
public struct Common_ClientHints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isMobile: Bool = false

  public var brand: [Common_ClientHintBrand] = []

  public var architecture: String = String()

  public var model: String = String()

  public var platform: String = String()

  public var platformVersion: String = String()

  public var uaFullVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// a part of ClientHints.
/// Next ID = 3.
public struct Common_ClientHintBrand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var brand: String = String()

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A sub-message containing Browser info.
/// Next ID = 5.
public struct Common_Browser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAgent: String = String()

  public var viewportSize: Common_Size {
    get {return _viewportSize ?? Common_Size()}
    set {_viewportSize = newValue}
  }
  /// Returns true if `viewportSize` has been explicitly set.
  public var hasViewportSize: Bool {return self._viewportSize != nil}
  /// Clears the value of `viewportSize`. Subsequent reads from it will return its default value.
  public mutating func clearViewportSize() {self._viewportSize = nil}

  public var clientHints: Common_ClientHints {
    get {return _clientHints ?? Common_ClientHints()}
    set {_clientHints = newValue}
  }
  /// Returns true if `clientHints` has been explicitly set.
  public var hasClientHints: Bool {return self._clientHints != nil}
  /// Clears the value of `clientHints`. Subsequent reads from it will return its default value.
  public mutating func clearClientHints() {self._clientHints = nil}

  public var referrer: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _viewportSize: Common_Size? = nil
  fileprivate var _clientHints: Common_ClientHints? = nil
}

/// Next ID = 4.
public struct Common_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [-90, 90]
  public var latitude: Double = 0

  /// [-180, 180]
  public var longitude: Double = 0

  /// Optional. Accuracy of location if known.
  public var accuracyInMeters: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message containing timing information.
///
/// We can add common timing info to this message.  Down the road, we might
/// make more specific Timing messages (e.g. MetricsTiming).  We can reuse
/// the field numbers.
///
/// Next ID = 4.
public struct Common_Timing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Supports custom properties per platform.
/// Next ID = 4.
public struct Common_Properties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var structField: Common_Properties.OneOf_StructField? = nil

  /// Optional.  Contains protobuf serialized bytes.
  public var structBytes: Data {
    get {
      if case .structBytes(let v)? = structField {return v}
      return Data()
    }
    set {structField = .structBytes(newValue)}
  }

  /// Optional.  Can be converted to/from JSON.
  public var `struct`: SwiftProtobuf.Google_Protobuf_Struct {
    get {
      if case .struct(let v)? = structField {return v}
      return SwiftProtobuf.Google_Protobuf_Struct()
    }
    set {structField = .struct(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StructField: Equatable {
    /// Optional.  Contains protobuf serialized bytes.
    case structBytes(Data)
    /// Optional.  Can be converted to/from JSON.
    case `struct`(SwiftProtobuf.Google_Protobuf_Struct)

  #if !swift(>=4.1)
    public static func ==(lhs: Common_Properties.OneOf_StructField, rhs: Common_Properties.OneOf_StructField) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structBytes, .structBytes): return {
        guard case .structBytes(let l) = lhs, case .structBytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.struct, .struct): return {
        guard case .struct(let l) = lhs, case .struct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "common"

extension Common_CurrencyCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CURRENCY_CODE"),
    1: .same(proto: "USD"),
    2: .same(proto: "EUR"),
    3: .same(proto: "JPY"),
    4: .same(proto: "GBP"),
    5: .same(proto: "AUD"),
    6: .same(proto: "CAD"),
    7: .same(proto: "CHF"),
    8: .same(proto: "CNY"),
    9: .same(proto: "HKD"),
    10: .same(proto: "NZD"),
    11: .same(proto: "SEK"),
    12: .same(proto: "KRW"),
    13: .same(proto: "SGD"),
    14: .same(proto: "NOK"),
    15: .same(proto: "MXN"),
    16: .same(proto: "INR"),
    17: .same(proto: "RUB"),
    18: .same(proto: "ZAR"),
    19: .same(proto: "TRY"),
    20: .same(proto: "BRL"),
  ]
}

extension Common_DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DEVICE_TYPE"),
    1: .same(proto: "DESKTOP"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "TABLET"),
  ]
}

extension Common_EntityPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "customer_id"),
    4: .standard(proto: "account_id"),
    5: .standard(proto: "campaign_id"),
    6: .standard(proto: "promotion_id"),
    3: .standard(proto: "content_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.customerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.contentID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.accountID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.campaignID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.promotionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if self.customerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.customerID, fieldNumber: 2)
    }
    if self.contentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.contentID, fieldNumber: 3)
    }
    if self.accountID != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountID, fieldNumber: 4)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularUInt64Field(value: self.campaignID, fieldNumber: 5)
    }
    if self.promotionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.promotionID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_EntityPath, rhs: Common_EntityPath) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.customerID != rhs.customerID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.promotionID != rhs.promotionID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Money: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Money"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "currency_code"),
    2: .standard(proto: "amount_micros"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.currencyCode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amountMicros) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.currencyCode != .unknownCurrencyCode {
      try visitor.visitSingularEnumField(value: self.currencyCode, fieldNumber: 1)
    }
    if self.amountMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.amountMicros, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Money, rhs: Common_Money) -> Bool {
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.amountMicros != rhs.amountMicros {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    3: .standard(proto: "is_internal_user"),
    4: .standard(proto: "ignore_usage"),
    5: .standard(proto: "anon_user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isInternalUser) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ignoreUsage) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.anonUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.isInternalUser != false {
      try visitor.visitSingularBoolField(value: self.isInternalUser, fieldNumber: 3)
    }
    if self.ignoreUsage != false {
      try visitor.visitSingularBoolField(value: self.ignoreUsage, fieldNumber: 4)
    }
    if !self.anonUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.anonUserID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UserInfo, rhs: Common_UserInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.isInternalUser != rhs.isInternalUser {return false}
    if lhs.ignoreUsage != rhs.ignoreUsage {return false}
    if lhs.anonUserID != rhs.anonUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_type"),
    2: .standard(proto: "traffic_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.clientType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.trafficType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientType != .unknownRequestClient {
      try visitor.visitSingularEnumField(value: self.clientType, fieldNumber: 1)
    }
    if self.trafficType != .unknownTrafficType {
      try visitor.visitSingularEnumField(value: self.trafficType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ClientInfo, rhs: Common_ClientInfo) -> Bool {
    if lhs.clientType != rhs.clientType {return false}
    if lhs.trafficType != rhs.trafficType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ClientInfo.ClientType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REQUEST_CLIENT"),
    1: .same(proto: "PLATFORM_SERVER"),
    2: .same(proto: "PLATFORM_CLIENT"),
  ]
}

extension Common_ClientInfo.TrafficType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TRAFFIC_TYPE"),
    1: .same(proto: "PRODUCTION"),
    2: .same(proto: "REPLAY"),
    4: .same(proto: "SHADOW"),
  ]
}

extension Common_Locale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Locale"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "language_code"),
    2: .standard(proto: "region_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Locale, rhs: Common_Locale) -> Bool {
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Size"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Size, rhs: Common_Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Screen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Screen, rhs: Common_Screen) -> Bool {
    if lhs._size != rhs._size {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_type"),
    2: .same(proto: "brand"),
    3: .same(proto: "manufacturer"),
    4: .same(proto: "identifier"),
    5: .standard(proto: "os_version"),
    6: .same(proto: "locale"),
    7: .same(proto: "screen"),
    8: .standard(proto: "ip_address"),
    9: .same(proto: "location"),
    10: .same(proto: "browser"),
    11: .standard(proto: "platform_app_version"),
    12: .standard(proto: "promoted_mobile_sdk_version"),
  ]

  fileprivate class _StorageClass {
    var _deviceType: Common_DeviceType = .unknownDeviceType
    var _brand: String = String()
    var _manufacturer: String = String()
    var _identifier: String = String()
    var _osVersion: String = String()
    var _locale: Common_Locale? = nil
    var _screen: Common_Screen? = nil
    var _ipAddress: String = String()
    var _location: Common_Location? = nil
    var _browser: Common_Browser? = nil
    var _platformAppVersion: String = String()
    var _promotedMobileSdkVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceType = source._deviceType
      _brand = source._brand
      _manufacturer = source._manufacturer
      _identifier = source._identifier
      _osVersion = source._osVersion
      _locale = source._locale
      _screen = source._screen
      _ipAddress = source._ipAddress
      _location = source._location
      _browser = source._browser
      _platformAppVersion = source._platformAppVersion
      _promotedMobileSdkVersion = source._promotedMobileSdkVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._deviceType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._brand) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._manufacturer) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._identifier) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._osVersion) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._locale) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._screen) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._ipAddress) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._browser) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._platformAppVersion) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._promotedMobileSdkVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._deviceType != .unknownDeviceType {
        try visitor.visitSingularEnumField(value: _storage._deviceType, fieldNumber: 1)
      }
      if !_storage._brand.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brand, fieldNumber: 2)
      }
      if !_storage._manufacturer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._manufacturer, fieldNumber: 3)
      }
      if !_storage._identifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identifier, fieldNumber: 4)
      }
      if !_storage._osVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._osVersion, fieldNumber: 5)
      }
      if let v = _storage._locale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._screen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._ipAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ipAddress, fieldNumber: 8)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._browser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._platformAppVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._platformAppVersion, fieldNumber: 11)
      }
      if !_storage._promotedMobileSdkVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._promotedMobileSdkVersion, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Device, rhs: Common_Device) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceType != rhs_storage._deviceType {return false}
        if _storage._brand != rhs_storage._brand {return false}
        if _storage._manufacturer != rhs_storage._manufacturer {return false}
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._osVersion != rhs_storage._osVersion {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._screen != rhs_storage._screen {return false}
        if _storage._ipAddress != rhs_storage._ipAddress {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._browser != rhs_storage._browser {return false}
        if _storage._platformAppVersion != rhs_storage._platformAppVersion {return false}
        if _storage._promotedMobileSdkVersion != rhs_storage._promotedMobileSdkVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ClientHints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_mobile"),
    2: .same(proto: "brand"),
    3: .same(proto: "architecture"),
    4: .same(proto: "model"),
    5: .same(proto: "platform"),
    6: .standard(proto: "platform_version"),
    7: .standard(proto: "ua_full_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isMobile) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.brand) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.platformVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.uaFullVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMobile != false {
      try visitor.visitSingularBoolField(value: self.isMobile, fieldNumber: 1)
    }
    if !self.brand.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.brand, fieldNumber: 2)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 3)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 4)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 5)
    }
    if !self.platformVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.platformVersion, fieldNumber: 6)
    }
    if !self.uaFullVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.uaFullVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ClientHints, rhs: Common_ClientHints) -> Bool {
    if lhs.isMobile != rhs.isMobile {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.model != rhs.model {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.platformVersion != rhs.platformVersion {return false}
    if lhs.uaFullVersion != rhs.uaFullVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_ClientHintBrand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHintBrand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brand"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_ClientHintBrand, rhs: Common_ClientHintBrand) -> Bool {
    if lhs.brand != rhs.brand {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Browser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Browser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_agent"),
    2: .standard(proto: "viewport_size"),
    3: .standard(proto: "client_hints"),
    4: .same(proto: "referrer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._viewportSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientHints) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.referrer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 1)
    }
    if let v = self._viewportSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._clientHints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.referrer.isEmpty {
      try visitor.visitSingularStringField(value: self.referrer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Browser, rhs: Common_Browser) -> Bool {
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs._viewportSize != rhs._viewportSize {return false}
    if lhs._clientHints != rhs._clientHints {return false}
    if lhs.referrer != rhs.referrer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .standard(proto: "accuracy_in_meters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.accuracyInMeters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    if self.accuracyInMeters != 0 {
      try visitor.visitSingularDoubleField(value: self.accuracyInMeters, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Location, rhs: Common_Location) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.accuracyInMeters != rhs.accuracyInMeters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Timing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Timing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_log_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Timing, rhs: Common_Timing) -> Bool {
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Properties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Properties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "struct_bytes"),
    2: .same(proto: "struct"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.structField != nil {try decoder.handleConflictingOneOf()}
          self.structField = .structBytes(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        var hadOneofValue = false
        if let current = self.structField {
          hadOneofValue = true
          if case .struct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.structField = .struct(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.structField {
    case .structBytes?: try {
      guard case .structBytes(let v)? = self.structField else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .struct?: try {
      guard case .struct(let v)? = self.structField else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Properties, rhs: Common_Properties) -> Bool {
    if lhs.structField != rhs.structField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
