// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/common/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Common_CurrencyCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownCurrencyCode // = 0
  case usd // = 1
  case eur // = 2
  case jpy // = 3
  case gbp // = 4
  case aud // = 5
  case cad // = 6
  case chf // = 7
  case cny // = 8
  case hkd // = 9
  case nzd // = 10
  case sek // = 11
  case krw // = 12
  case sgd // = 13
  case nok // = 14
  case mxn // = 15
  case inr // = 16
  case rub // = 17
  case zar // = 18
  case `try` // = 19
  case brl // = 20
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownCurrencyCode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownCurrencyCode
    case 1: self = .usd
    case 2: self = .eur
    case 3: self = .jpy
    case 4: self = .gbp
    case 5: self = .aud
    case 6: self = .cad
    case 7: self = .chf
    case 8: self = .cny
    case 9: self = .hkd
    case 10: self = .nzd
    case 11: self = .sek
    case 12: self = .krw
    case 13: self = .sgd
    case 14: self = .nok
    case 15: self = .mxn
    case 16: self = .inr
    case 17: self = .rub
    case 18: self = .zar
    case 19: self = .try
    case 20: self = .brl
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownCurrencyCode: return 0
    case .usd: return 1
    case .eur: return 2
    case .jpy: return 3
    case .gbp: return 4
    case .aud: return 5
    case .cad: return 6
    case .chf: return 7
    case .cny: return 8
    case .hkd: return 9
    case .nzd: return 10
    case .sek: return 11
    case .krw: return 12
    case .sgd: return 13
    case .nok: return 14
    case .mxn: return 15
    case .inr: return 16
    case .rub: return 17
    case .zar: return 18
    case .try: return 19
    case .brl: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Common_CurrencyCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Common_CurrencyCode] = [
    .unknownCurrencyCode,
    .usd,
    .eur,
    .jpy,
    .gbp,
    .aud,
    .cad,
    .chf,
    .cny,
    .hkd,
    .nzd,
    .sek,
    .krw,
    .sgd,
    .nok,
    .mxn,
    .inr,
    .rub,
    .zar,
    .try,
    .brl,
  ]
}

#endif  // swift(>=4.2)

public struct Common_EntityPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformID: UInt64 = 0

  public var customerID: UInt64 = 0

  public var accountID: UInt64 = 0

  public var campaignID: UInt64 = 0

  public var promotionID: UInt64 = 0

  public var contentID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Common submessage that scopes helps scope a request/log to a user.
///
/// Next ID = 3.
public struct Common_UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  The Platform's actual user ID.
  /// This field will be cleared from our transaction logs.
  public var userID: String = String()

  /// Optional.  This is a user UUID that is different from user_id and
  /// can quickly be disassociated from the actual user ID.  This is useful:
  /// 1. in case the user wants to be forgotten.
  /// 2. logging unauthenticated users.
  /// The user UUID is in a different ID space than user_id.
  public var logUserID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message containing timing information.
///
/// We can add common timing info to this message.  Down the road, we might
/// make more specific Timing messages (e.g. MetricsTiming).  We can reuse
/// the field numbers.
///
/// Next ID = 4.
public struct Common_Timing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Read-only.  This is set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Internal to our metrics pipeline.  Currently set by kafka and used to
  /// manage state for event joining.
  public var logTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Supports custom properties per platform.
/// Next ID = 3.
public struct Common_Properties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var structField: Common_Properties.OneOf_StructField? = nil

  /// Optional.  Contains protobuf serialized bytes.
  public var structBytes: Data {
    get {
      if case .structBytes(let v)? = structField {return v}
      return Data()
    }
    set {structField = .structBytes(newValue)}
  }

  /// Optional.  Can be converted to/from JSON.
  public var `struct`: SwiftProtobuf.Google_Protobuf_Struct {
    get {
      if case .struct(let v)? = structField {return v}
      return SwiftProtobuf.Google_Protobuf_Struct()
    }
    set {structField = .struct(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StructField: Equatable {
    /// Optional.  Contains protobuf serialized bytes.
    case structBytes(Data)
    /// Optional.  Can be converted to/from JSON.
    case `struct`(SwiftProtobuf.Google_Protobuf_Struct)

  #if !swift(>=4.1)
    public static func ==(lhs: Common_Properties.OneOf_StructField, rhs: Common_Properties.OneOf_StructField) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structBytes, .structBytes): return {
        guard case .structBytes(let l) = lhs, case .structBytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.struct, .struct): return {
        guard case .struct(let l) = lhs, case .struct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "common"

extension Common_CurrencyCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CURRENCY_CODE"),
    1: .same(proto: "USD"),
    2: .same(proto: "EUR"),
    3: .same(proto: "JPY"),
    4: .same(proto: "GBP"),
    5: .same(proto: "AUD"),
    6: .same(proto: "CAD"),
    7: .same(proto: "CHF"),
    8: .same(proto: "CNY"),
    9: .same(proto: "HKD"),
    10: .same(proto: "NZD"),
    11: .same(proto: "SEK"),
    12: .same(proto: "KRW"),
    13: .same(proto: "SGD"),
    14: .same(proto: "NOK"),
    15: .same(proto: "MXN"),
    16: .same(proto: "INR"),
    17: .same(proto: "RUB"),
    18: .same(proto: "ZAR"),
    19: .same(proto: "TRY"),
    20: .same(proto: "BRL"),
  ]
}

extension Common_EntityPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "customer_id"),
    4: .standard(proto: "account_id"),
    5: .standard(proto: "campaign_id"),
    6: .standard(proto: "promotion_id"),
    3: .standard(proto: "content_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.customerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.contentID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.accountID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.campaignID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.promotionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if self.customerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.customerID, fieldNumber: 2)
    }
    if self.contentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.contentID, fieldNumber: 3)
    }
    if self.accountID != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountID, fieldNumber: 4)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularUInt64Field(value: self.campaignID, fieldNumber: 5)
    }
    if self.promotionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.promotionID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_EntityPath, rhs: Common_EntityPath) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.customerID != rhs.customerID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.promotionID != rhs.promotionID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "log_user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_UserInfo, rhs: Common_UserInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Timing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Timing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_log_timestamp"),
    2: .standard(proto: "event_api_timestamp"),
    3: .standard(proto: "log_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.logTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 1)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 2)
    }
    if self.logTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.logTimestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Timing, rhs: Common_Timing) -> Bool {
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.logTimestamp != rhs.logTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Properties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Properties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "struct_bytes"),
    2: .same(proto: "struct"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.structField != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.structField = .structBytes(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        if let current = self.structField {
          try decoder.handleConflictingOneOf()
          if case .struct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.structField = .struct(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.structField {
    case .structBytes?: try {
      guard case .structBytes(let v)? = self.structField else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .struct?: try {
      guard case .struct(let v)? = self.structField else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Common_Properties, rhs: Common_Properties) -> Bool {
    if lhs.structField != rhs.structField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
