// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/delivery/blender.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// See: https://github.com/promotedai/blender for README
/// Next ID = 11.
public struct Delivery_BlenderRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of item attribute that this rule applies to. It may be a JSON key path.
  public var attributeName: String = String()

  public var rule: Delivery_BlenderRule.OneOf_Rule? = nil

  public var positiveRule: Delivery_PositiveRule {
    get {
      if case .positiveRule(let v)? = rule {return v}
      return Delivery_PositiveRule()
    }
    set {rule = .positiveRule(newValue)}
  }

  public var insertRule: Delivery_InsertRule {
    get {
      if case .insertRule(let v)? = rule {return v}
      return Delivery_InsertRule()
    }
    set {rule = .insertRule(newValue)}
  }

  public var negativeRule: Delivery_NegativeRule {
    get {
      if case .negativeRule(let v)? = rule {return v}
      return Delivery_NegativeRule()
    }
    set {rule = .negativeRule(newValue)}
  }

  public var diversityRule: Delivery_DiversityRule {
    get {
      if case .diversityRule(let v)? = rule {return v}
      return Delivery_DiversityRule()
    }
    set {rule = .diversityRule(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Rule: Equatable {
    case positiveRule(Delivery_PositiveRule)
    case insertRule(Delivery_InsertRule)
    case negativeRule(Delivery_NegativeRule)
    case diversityRule(Delivery_DiversityRule)

  #if !swift(>=4.1)
    public static func ==(lhs: Delivery_BlenderRule.OneOf_Rule, rhs: Delivery_BlenderRule.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.positiveRule, .positiveRule): return {
        guard case .positiveRule(let l) = lhs, case .positiveRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertRule, .insertRule): return {
        guard case .insertRule(let l) = lhs, case .insertRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.negativeRule, .negativeRule): return {
        guard case .negativeRule(let l) = lhs, case .negativeRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diversityRule, .diversityRule): return {
        guard case .diversityRule(let l) = lhs, case .diversityRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A positive rule selects insertions by their score if they are associated with the same attribute
/// that the rule is associated with.
///
/// If one seeks to fill a position `p` with an insertion, then one positive rule is selected by
/// random out of all positive rules. The selection process works in the following way:
///
/// 1. positive rules are filtered by whether for a given rule there exist any insertions that could
///    potentially be selected (meaning there are insertions that are not yet associated with a
///    different position, that are associated with the same attribute as a given rule, and that
///    have not been filtered out by negative rules [see the comment on negative rules for that]);
/// 2. the rules remaining after 1. are filtered for the condition
///    `rule.min_pos <= p <= rule.max_pos`;
/// 3. from the rules remaining after 2. one is selected by random based on their weight in
///    `rule.select_pct`.
///
/// After a positive rule has been selected, the insertion of the highest score is associated with
/// position `p` (if, remembering point 1., that insertion is available to be allocated, has the
/// same associated attribute as the selected rule, and is not ruled out by application of negative
/// rules).
///
/// Note that there is a chance of no rule (and hence no insertion) being selected if the sum of all
/// rules selected in step 3. is less than 100.0. The probability of that happening is `100 - sum`.
///
/// Positive rules are similar to insert rules, but used in a different context. While items can be
/// selected just based on insert rules, positive rules are used in tandem with negative rules.
/// First, negative rules are tested to filter out items. Afterwards, a positive rule is used to
/// select items just like an insert rule (just without the filtered out items).
///
/// Next ID = 4.
public struct Delivery_PositiveRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value between 0 and 100. The weight of this rule to be selected.
  ///
  /// If the sum `W` of all weights is less than 100, then the chance N of no weight being chosen is
  /// assigned the weight `N = 100 - W`.
  ///
  /// Examples (given weights `{a, b, ..., z}`, each entry corresponds to a rule with weight `a`,
  /// `b`, `c`, etc):
  /// + `{100, 100}`: 2 rules with equal weight: 50% chance of each being selected
  /// + `{50, 50}`: as above
  /// + `{25, 25}`: each rule has a 25% chance of being selected; there is a 50% chance of no rule
  ///    being selected
  /// + `{10, 10, 10, 10, 10`}: each of the 5 rules has a 5% chance of being selected; there is a
  ///   is a 50% chance of no rule being selected.
  /// + `{50, 100}`: 2/3 chance of selecting the rule with weight 100, 1/3 chance to select that of
  ///   weight 50.
  ///
  /// NOTE: a value of 0 means this rule will never be selected.
  ///
  /// Default: `100.0`
  public var selectPct: Double {
    get {return _selectPct ?? 0}
    set {_selectPct = newValue}
  }
  /// Returns true if `selectPct` has been explicitly set.
  public var hasSelectPct: Bool {return self._selectPct != nil}
  /// Clears the value of `selectPct`. Subsequent reads from it will return its default value.
  public mutating func clearSelectPct() {self._selectPct = nil}

  /// The minimum position that this rule applies to. If one seeks to fill a position `p < min_pos`,
  /// then this rule will not be considered for selection. `min_pos <= max_pos` must hold.
  ///
  /// Default: `0`
  public var minPos: UInt64 {
    get {return _minPos ?? 0}
    set {_minPos = newValue}
  }
  /// Returns true if `minPos` has been explicitly set.
  public var hasMinPos: Bool {return self._minPos != nil}
  /// Clears the value of `minPos`. Subsequent reads from it will return its default value.
  public mutating func clearMinPos() {self._minPos = nil}

  /// The maximum position that this rule applies to. If one seeks to fill a position `p > max_pos`,
  /// then this rule will not be considered for selection. `max_pos >= min_pos` must hold.
  ///
  /// Default `uint64::MAX`
  public var maxPos: UInt64 {
    get {return _maxPos ?? 0}
    set {_maxPos = newValue}
  }
  /// Returns true if `maxPos` has been explicitly set.
  public var hasMaxPos: Bool {return self._maxPos != nil}
  /// Clears the value of `maxPos`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPos() {self._maxPos = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selectPct: Double? = nil
  fileprivate var _minPos: UInt64? = nil
  fileprivate var _maxPos: UInt64? = nil
}

/// An insert rule selects insertions by their score if they are associated with the same attribute
/// that the rule is associated with.
///
/// If one seeks to fill a position `p` with an insertion, then one insert rule is selected by
/// random out of all insert rules. The selection process works in the following way:
///
/// 1. insert rules are filtered by whether for a given rule there exist any insertions that could
///    potentially be selected (meaning there are insertions that are not yet associated with a
///    different position, and that are associated with the same attribute as a given rule);
/// 2. the rules remaining after 1. are filtered for the condition
///    `rule.min_pos <= p <= rule.max_pos`;
/// 3. from the rules remaining after 2. one is selected by random based on their weight in
///    `rule.select_pct`.
///
/// After an insert rule has been selected, the insertion of the highest score is associated with
/// position `p` (if, remembering point 1., that insertion is available to be allocated, and has the
/// same associated attribute as the selected rule).
///
/// Note that there is a chance of no rule (and hence no insertion) being selected if the sum of all
/// rules selected in step 3. is less than 100.0. The probability of that happening is `100 - sum`.
/// 
/// Next ID = 4.
public struct Delivery_InsertRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value between 0 and 100. The weight of this rule to be selected.
  ///
  /// If the sum `W` of all weights is less than 100, then the chance N of no weight being chosen is
  /// assigned the weight `N = 100 - W`.
  ///
  /// Examples (given weights `{a, b, ..., z}`, each entry corresponds to a rule with weight `a`,
  /// `b`, `c`, etc):
  /// + `{100, 100}`: 2 rules with equal weight: 50% chance of each being selected
  /// + `{50, 50}`: as above
  /// + `{25, 25}`: each rule has a 25% chance of being selected; there is a 50% chance of no rule
  ///    being selected
  /// + `{10, 10, 10, 10, 10`}: each of the 5 rules has a 5% chance of being selected; there is a
  ///   is a 50% chance of no rule being selected.
  /// + `{50, 100}`: 2/3 chance of selecting the rule with weight 100, 1/3 chance to select that of
  ///   weight 50.
  ///
  /// NOTE: a value of 0 means this rule will never be selected.
  ///
  /// Default: `100.0`
  public var selectPct: Double {
    get {return _selectPct ?? 0}
    set {_selectPct = newValue}
  }
  /// Returns true if `selectPct` has been explicitly set.
  public var hasSelectPct: Bool {return self._selectPct != nil}
  /// Clears the value of `selectPct`. Subsequent reads from it will return its default value.
  public mutating func clearSelectPct() {self._selectPct = nil}

  /// The minimum position that this rule applies to. If one seeks to fill a position `p < min_pos`,
  /// then this rule will not be considered for selection. `min_pos <= max_pos` must hold.
  ///
  /// Default: `0`
  public var minPos: UInt64 {
    get {return _minPos ?? 0}
    set {_minPos = newValue}
  }
  /// Returns true if `minPos` has been explicitly set.
  public var hasMinPos: Bool {return self._minPos != nil}
  /// Clears the value of `minPos`. Subsequent reads from it will return its default value.
  public mutating func clearMinPos() {self._minPos = nil}

  /// The maximum position that this rule applies to. If one seeks to fill a position `p > max_pos`,
  /// then this rule will not be considered for selection. `max_pos >= min_pos` must hold.
  ///
  /// Default `uint64::MAX`
  public var maxPos: UInt64 {
    get {return _maxPos ?? 0}
    set {_maxPos = newValue}
  }
  /// Returns true if `maxPos` has been explicitly set.
  public var hasMaxPos: Bool {return self._maxPos != nil}
  /// Clears the value of `maxPos`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPos() {self._maxPos = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selectPct: Double? = nil
  fileprivate var _minPos: UInt64? = nil
  fileprivate var _maxPos: UInt64? = nil
}

/// A negative rule tests if a given insertion may not be selected under application of positive
/// rules (see the description of positive rules to undertand that process).
/// 
/// A negative rule is associated with an attribute and applies to all those insertions that are
/// associated with the same attribute. The applicable insertions are tested against the conditions
/// laid out by the negative rule. If they fail one of the conditions, then the item is precluded
/// from being selected under the subsequent application of positive rules.
///
/// Next ID = 6.
public struct Delivery_NegativeRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value between 0 and 100. The probability that an item will be failed ("plucked) even if it
  /// passes all other conditions.
  ///
  /// NOTE: a value of 0 means that the item has to fail one of the other conditions to be discarded.
  /// A value of 100 means that an item will always be discarded, no matter the other conditions, as
  /// as long as it has an attribute matching this rule's.
  ///
  /// Default: `100.0`
  public var pluckPct: Double {
    get {return _pluckPct ?? 0}
    set {_pluckPct = newValue}
  }
  /// Returns true if `pluckPct` has been explicitly set.
  public var hasPluckPct: Bool {return self._pluckPct != nil}
  /// Clears the value of `pluckPct`. Subsequent reads from it will return its default value.
  public mutating func clearPluckPct() {self._pluckPct = nil}

  /// The minimum position that items with matching associated attribute can be placed in. Items
  /// with the same associated attribute as the negative rule will not be considered for selection
  /// if one seeks to fill a position `p < forbid_less_pos`.
  ///
  /// Default: `0`
  public var forbidLessPos: UInt64 {
    get {return _forbidLessPos ?? 0}
    set {_forbidLessPos = newValue}
  }
  /// Returns true if `forbidLessPos` has been explicitly set.
  public var hasForbidLessPos: Bool {return self._forbidLessPos != nil}
  /// Clears the value of `forbidLessPos`. Subsequent reads from it will return its default value.
  public mutating func clearForbidLessPos() {self._forbidLessPos = nil}

  /// The minimum number of positions between the current position and its precursor. For example,
  /// if `min_spacing = 1` and one seeks to fill a position `p`, then an item is discarded if the
  /// item at position `p-1` and the item under consideration have the same associated attribute as
  /// the current rule (note that attribute values do not have to match; only the fact that they
  /// have the same associated attribute matters).
  ///
  /// Default: `uint64::MAX`
  public var minSpacing: UInt64 {
    get {return _minSpacing ?? 0}
    set {_minSpacing = newValue}
  }
  /// Returns true if `minSpacing` has been explicitly set.
  public var hasMinSpacing: Bool {return self._minSpacing != nil}
  /// Clears the value of `minSpacing`. Subsequent reads from it will return its default value.
  public mutating func clearMinSpacing() {self._minSpacing = nil}

  /// The maximum position that items with matching associated attribute can be placed in. Items
  /// with the same associated attribute as the negative rule will not be considered for selection
  /// if one seeks to fill a position `p > forbid_greater_pos`.
  ///
  /// Default: `uint64::MAX`
  public var forbidGreaterPos: UInt64 {
    get {return _forbidGreaterPos ?? 0}
    set {_forbidGreaterPos = newValue}
  }
  /// Returns true if `forbidGreaterPos` has been explicitly set.
  public var hasForbidGreaterPos: Bool {return self._forbidGreaterPos != nil}
  /// Clears the value of `forbidGreaterPos`. Subsequent reads from it will return its default value.
  public mutating func clearForbidGreaterPos() {self._forbidGreaterPos = nil}

  /// The maximum number of items that are allowed to be allocated with the same attribute name as
  /// this rule. If `max_count` items have already been allocated in previous positions, then no
  /// more items with the attribute name can be allocated.
  ///
  /// Default: `uint64::MAX`
  public var maxCount: UInt64 {
    get {return _maxCount ?? 0}
    set {_maxCount = newValue}
  }
  /// Returns true if `maxCount` has been explicitly set.
  public var hasMaxCount: Bool {return self._maxCount != nil}
  /// Clears the value of `maxCount`. Subsequent reads from it will return its default value.
  public mutating func clearMaxCount() {self._maxCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pluckPct: Double? = nil
  fileprivate var _forbidLessPos: UInt64? = nil
  fileprivate var _minSpacing: UInt64? = nil
  fileprivate var _forbidGreaterPos: UInt64? = nil
  fileprivate var _maxCount: UInt64? = nil
}

/// Diversity rules modify the scores of insertions if equivalent insertions have been previously
/// allocated.
///
/// The purpose of diversity rules is to penalize equivalent insertions. Two insertions `i` and `j`
/// are considered equivalent if they are associated with the same attribute as the rule, and if
/// the value of said attribute is the same, i.e. the condition `i[attr] == j[attr]` and
/// `i[attr] != nil`.
/// Next ID = 2.
public struct Delivery_DiversityRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A factor modifying items' scores. If an item has been allocated at position `p`, then all the
  /// allocated item's value of the attribute with matching name is taken. All other items that a)
  /// have an attribute that the rule applies to, and b) share the same value as the just allocated
  /// item will have their score multiplied by `multi`.
  ///
  /// Example: if insertion `i` has been allocated at position `p`, then an insertion `j` will have
  /// its score modified by `p.score *= multi` if and only if
  /// `a[rule.attribute_name] == b[rule.attribute_name]` and if `a[rule.attribute_name] != nil`.
  ///
  /// NOTE: a multiplier `m <= 0.0` means that modified items will never be allocated again (because
  /// non-positive scores disqualify items outright). Multipliers of `m > 1.0` act as as a boost.
  /// To act as a penalty, it should be set `0.0 > m < 1.0`, but this is currently not enforced.
  public var multi: Double {
    get {return _multi ?? 0}
    set {_multi = newValue}
  }
  /// Returns true if `multi` has been explicitly set.
  public var hasMulti: Bool {return self._multi != nil}
  /// Clears the value of `multi`. Subsequent reads from it will return its default value.
  public mutating func clearMulti() {self._multi = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _multi: Double? = nil
}

/// Next ID = 3.
public struct Delivery_BlenderConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of blender rules.
  public var blenderRule: [Delivery_BlenderRule] = []

  public var qualityScoreConfig: Delivery_QualityScoreConfig {
    get {return _qualityScoreConfig ?? Delivery_QualityScoreConfig()}
    set {_qualityScoreConfig = newValue}
  }
  /// Returns true if `qualityScoreConfig` has been explicitly set.
  public var hasQualityScoreConfig: Bool {return self._qualityScoreConfig != nil}
  /// Clears the value of `qualityScoreConfig`. Subsequent reads from it will return its default value.
  public mutating func clearQualityScoreConfig() {self._qualityScoreConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _qualityScoreConfig: Delivery_QualityScoreConfig? = nil
}

/// See: https://github.com/promotedai/qualityscore
/// Next ID = 2.
public struct Delivery_QualityScoreConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var weightedSumTerm: [Delivery_QualityScoreTerm] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Next ID = 14.
public struct Delivery_QualityScoreTerm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// How to fetch the base values of this term vector.
  public var fetchMethod: Delivery_QualityScoreTerm.OneOf_FetchMethod? = nil

  /// A named vector provided from elsewhere.
  public var attributeName: String {
    get {
      if case .attributeName(let v)? = fetchMethod {return v}
      return String()
    }
    set {fetchMethod = .attributeName(newValue)}
  }

  /// Randomly generated values from a normal distribution.
  public var randomNormal: Delivery_NormalDistribution {
    get {
      if case .randomNormal(let v)? = fetchMethod {return v}
      return Delivery_NormalDistribution()
    }
    set {fetchMethod = .randomNormal(newValue)}
  }

  /// A constant value of ones. Set to any constant with offset and/or weight.
  /// Set to "true" to indicate that this option is set by convention.
  public var ones: Bool {
    get {
      if case .ones(let v)? = fetchMethod {return v}
      return false
    }
    set {fetchMethod = .ones(newValue)}
  }

  /// Maximum limit of underlying value (before weight and offset).
  public var fetchHigh: Double {
    get {return _fetchHigh ?? 0}
    set {_fetchHigh = newValue}
  }
  /// Returns true if `fetchHigh` has been explicitly set.
  public var hasFetchHigh: Bool {return self._fetchHigh != nil}
  /// Clears the value of `fetchHigh`. Subsequent reads from it will return its default value.
  public mutating func clearFetchHigh() {self._fetchHigh = nil}

  /// Minimum limit of underlying value (before weight and offset).
  public var fetchLow: Double {
    get {return _fetchLow ?? 0}
    set {_fetchLow = newValue}
  }
  /// Returns true if `fetchLow` has been explicitly set.
  public var hasFetchLow: Bool {return self._fetchLow != nil}
  /// Clears the value of `fetchLow`. Subsequent reads from it will return its default value.
  public mutating func clearFetchLow() {self._fetchLow = nil}

  /// Multiply by this value. default =1 (no multiply).
  public var weight: Double = 0

  /// Add by this value. default = 0 (no addition)
  public var offset: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// How to fetch the base values of this term vector.
  public enum OneOf_FetchMethod: Equatable {
    /// A named vector provided from elsewhere.
    case attributeName(String)
    /// Randomly generated values from a normal distribution.
    case randomNormal(Delivery_NormalDistribution)
    /// A constant value of ones. Set to any constant with offset and/or weight.
    /// Set to "true" to indicate that this option is set by convention.
    case ones(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Delivery_QualityScoreTerm.OneOf_FetchMethod, rhs: Delivery_QualityScoreTerm.OneOf_FetchMethod) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.attributeName, .attributeName): return {
        guard case .attributeName(let l) = lhs, case .attributeName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomNormal, .randomNormal): return {
        guard case .randomNormal(let l) = lhs, case .randomNormal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ones, .ones): return {
        guard case .ones(let l) = lhs, case .ones(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _fetchHigh: Double? = nil
  fileprivate var _fetchLow: Double? = nil
}

/// Next ID = 3.
public struct Delivery_NormalDistribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mean: Double = 0

  public var variance: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "delivery"

extension Delivery_BlenderRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlenderRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_name"),
    6: .standard(proto: "positive_rule"),
    7: .standard(proto: "insert_rule"),
    8: .standard(proto: "negative_rule"),
    9: .standard(proto: "diversity_rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.attributeName) }()
      case 6: try {
        var v: Delivery_PositiveRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .positiveRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .positiveRule(v)
        }
      }()
      case 7: try {
        var v: Delivery_InsertRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .insertRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .insertRule(v)
        }
      }()
      case 8: try {
        var v: Delivery_NegativeRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .negativeRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .negativeRule(v)
        }
      }()
      case 9: try {
        var v: Delivery_DiversityRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .diversityRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .diversityRule(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attributeName.isEmpty {
      try visitor.visitSingularStringField(value: self.attributeName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.rule {
    case .positiveRule?: try {
      guard case .positiveRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .insertRule?: try {
      guard case .insertRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .negativeRule?: try {
      guard case .negativeRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .diversityRule?: try {
      guard case .diversityRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_BlenderRule, rhs: Delivery_BlenderRule) -> Bool {
    if lhs.attributeName != rhs.attributeName {return false}
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_PositiveRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositiveRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "select_pct"),
    2: .standard(proto: "min_pos"),
    3: .standard(proto: "max_pos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._selectPct) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._minPos) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxPos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._selectPct {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._minPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._maxPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_PositiveRule, rhs: Delivery_PositiveRule) -> Bool {
    if lhs._selectPct != rhs._selectPct {return false}
    if lhs._minPos != rhs._minPos {return false}
    if lhs._maxPos != rhs._maxPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_InsertRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InsertRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "select_pct"),
    2: .standard(proto: "min_pos"),
    3: .standard(proto: "max_pos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._selectPct) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._minPos) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxPos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._selectPct {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._minPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._maxPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_InsertRule, rhs: Delivery_InsertRule) -> Bool {
    if lhs._selectPct != rhs._selectPct {return false}
    if lhs._minPos != rhs._minPos {return false}
    if lhs._maxPos != rhs._maxPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_NegativeRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NegativeRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pluck_pct"),
    2: .standard(proto: "forbid_less_pos"),
    3: .standard(proto: "min_spacing"),
    4: .standard(proto: "forbid_greater_pos"),
    5: .standard(proto: "max_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._pluckPct) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._forbidLessPos) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._minSpacing) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._forbidGreaterPos) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._maxCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pluckPct {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._forbidLessPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._minSpacing {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._forbidGreaterPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._maxCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_NegativeRule, rhs: Delivery_NegativeRule) -> Bool {
    if lhs._pluckPct != rhs._pluckPct {return false}
    if lhs._forbidLessPos != rhs._forbidLessPos {return false}
    if lhs._minSpacing != rhs._minSpacing {return false}
    if lhs._forbidGreaterPos != rhs._forbidGreaterPos {return false}
    if lhs._maxCount != rhs._maxCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_DiversityRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiversityRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._multi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._multi {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_DiversityRule, rhs: Delivery_DiversityRule) -> Bool {
    if lhs._multi != rhs._multi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_BlenderConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlenderConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blender_rule"),
    2: .standard(proto: "quality_score_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blenderRule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._qualityScoreConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blenderRule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blenderRule, fieldNumber: 1)
    }
    if let v = self._qualityScoreConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_BlenderConfig, rhs: Delivery_BlenderConfig) -> Bool {
    if lhs.blenderRule != rhs.blenderRule {return false}
    if lhs._qualityScoreConfig != rhs._qualityScoreConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_QualityScoreConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QualityScoreConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weighted_sum_term"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.weightedSumTerm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weightedSumTerm.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weightedSumTerm, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_QualityScoreConfig, rhs: Delivery_QualityScoreConfig) -> Bool {
    if lhs.weightedSumTerm != rhs.weightedSumTerm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_QualityScoreTerm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QualityScoreTerm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_name"),
    2: .standard(proto: "random_normal"),
    3: .same(proto: "ones"),
    10: .standard(proto: "fetch_high"),
    11: .standard(proto: "fetch_low"),
    12: .same(proto: "weight"),
    13: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.fetchMethod != nil {try decoder.handleConflictingOneOf()}
          self.fetchMethod = .attributeName(v)
        }
      }()
      case 2: try {
        var v: Delivery_NormalDistribution?
        var hadOneofValue = false
        if let current = self.fetchMethod {
          hadOneofValue = true
          if case .randomNormal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.fetchMethod = .randomNormal(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.fetchMethod != nil {try decoder.handleConflictingOneOf()}
          self.fetchMethod = .ones(v)
        }
      }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self._fetchHigh) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self._fetchLow) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self.weight) }()
      case 13: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.fetchMethod {
    case .attributeName?: try {
      guard case .attributeName(let v)? = self.fetchMethod else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .randomNormal?: try {
      guard case .randomNormal(let v)? = self.fetchMethod else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ones?: try {
      guard case .ones(let v)? = self.fetchMethod else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if let v = self._fetchHigh {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
    }
    if let v = self._fetchLow {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 11)
    }
    if self.weight != 0 {
      try visitor.visitSingularDoubleField(value: self.weight, fieldNumber: 12)
    }
    if self.offset != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_QualityScoreTerm, rhs: Delivery_QualityScoreTerm) -> Bool {
    if lhs.fetchMethod != rhs.fetchMethod {return false}
    if lhs._fetchHigh != rhs._fetchHigh {return false}
    if lhs._fetchLow != rhs._fetchLow {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_NormalDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NormalDistribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mean"),
    2: .same(proto: "variance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.mean) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.variance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mean != 0 {
      try visitor.visitSingularDoubleField(value: self.mean, fieldNumber: 1)
    }
    if self.variance != 0 {
      try visitor.visitSingularDoubleField(value: self.variance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_NormalDistribution, rhs: Delivery_NormalDistribution) -> Bool {
    if lhs.mean != rhs.mean {return false}
    if lhs.variance != rhs.variance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
