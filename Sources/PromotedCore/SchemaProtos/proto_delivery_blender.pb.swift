// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/delivery/blender.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// See: https://github.com/promotedai/blender for README
/// Next ID = 11.
public struct Delivery_BlenderRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of item attribute that this rule applies to. It may be a JSON key path.
  public var attributeName: String = String()

  public var rule: Delivery_BlenderRule.OneOf_Rule? = nil

  public var positiveRule: Delivery_PositiveRule {
    get {
      if case .positiveRule(let v)? = rule {return v}
      return Delivery_PositiveRule()
    }
    set {rule = .positiveRule(newValue)}
  }

  public var insertRule: Delivery_InsertRule {
    get {
      if case .insertRule(let v)? = rule {return v}
      return Delivery_InsertRule()
    }
    set {rule = .insertRule(newValue)}
  }

  public var negativeRule: Delivery_NegativeRule {
    get {
      if case .negativeRule(let v)? = rule {return v}
      return Delivery_NegativeRule()
    }
    set {rule = .negativeRule(newValue)}
  }

  public var diversityRule: Delivery_DiversityRule {
    get {
      if case .diversityRule(let v)? = rule {return v}
      return Delivery_DiversityRule()
    }
    set {rule = .diversityRule(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Rule: Equatable {
    case positiveRule(Delivery_PositiveRule)
    case insertRule(Delivery_InsertRule)
    case negativeRule(Delivery_NegativeRule)
    case diversityRule(Delivery_DiversityRule)

  #if !swift(>=4.1)
    public static func ==(lhs: Delivery_BlenderRule.OneOf_Rule, rhs: Delivery_BlenderRule.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.positiveRule, .positiveRule): return {
        guard case .positiveRule(let l) = lhs, case .positiveRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertRule, .insertRule): return {
        guard case .insertRule(let l) = lhs, case .insertRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.negativeRule, .negativeRule): return {
        guard case .negativeRule(let l) = lhs, case .negativeRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diversityRule, .diversityRule): return {
        guard case .diversityRule(let l) = lhs, case .diversityRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Next ID = 4.
public struct Delivery_PositiveRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var selectPct: Double {
    get {return _selectPct ?? 0}
    set {_selectPct = newValue}
  }
  /// Returns true if `selectPct` has been explicitly set.
  public var hasSelectPct: Bool {return self._selectPct != nil}
  /// Clears the value of `selectPct`. Subsequent reads from it will return its default value.
  public mutating func clearSelectPct() {self._selectPct = nil}

  public var minPos: UInt64 {
    get {return _minPos ?? 0}
    set {_minPos = newValue}
  }
  /// Returns true if `minPos` has been explicitly set.
  public var hasMinPos: Bool {return self._minPos != nil}
  /// Clears the value of `minPos`. Subsequent reads from it will return its default value.
  public mutating func clearMinPos() {self._minPos = nil}

  public var maxPos: UInt64 {
    get {return _maxPos ?? 0}
    set {_maxPos = newValue}
  }
  /// Returns true if `maxPos` has been explicitly set.
  public var hasMaxPos: Bool {return self._maxPos != nil}
  /// Clears the value of `maxPos`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPos() {self._maxPos = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selectPct: Double? = nil
  fileprivate var _minPos: UInt64? = nil
  fileprivate var _maxPos: UInt64? = nil
}

/// Next ID = 4.
public struct Delivery_InsertRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var selectPct: Double {
    get {return _selectPct ?? 0}
    set {_selectPct = newValue}
  }
  /// Returns true if `selectPct` has been explicitly set.
  public var hasSelectPct: Bool {return self._selectPct != nil}
  /// Clears the value of `selectPct`. Subsequent reads from it will return its default value.
  public mutating func clearSelectPct() {self._selectPct = nil}

  public var minPos: UInt64 {
    get {return _minPos ?? 0}
    set {_minPos = newValue}
  }
  /// Returns true if `minPos` has been explicitly set.
  public var hasMinPos: Bool {return self._minPos != nil}
  /// Clears the value of `minPos`. Subsequent reads from it will return its default value.
  public mutating func clearMinPos() {self._minPos = nil}

  public var maxPos: UInt64 {
    get {return _maxPos ?? 0}
    set {_maxPos = newValue}
  }
  /// Returns true if `maxPos` has been explicitly set.
  public var hasMaxPos: Bool {return self._maxPos != nil}
  /// Clears the value of `maxPos`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPos() {self._maxPos = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selectPct: Double? = nil
  fileprivate var _minPos: UInt64? = nil
  fileprivate var _maxPos: UInt64? = nil
}

/// Next ID = 6.
public struct Delivery_NegativeRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pluckPct: Double {
    get {return _pluckPct ?? 0}
    set {_pluckPct = newValue}
  }
  /// Returns true if `pluckPct` has been explicitly set.
  public var hasPluckPct: Bool {return self._pluckPct != nil}
  /// Clears the value of `pluckPct`. Subsequent reads from it will return its default value.
  public mutating func clearPluckPct() {self._pluckPct = nil}

  public var forbidLessPos: UInt64 {
    get {return _forbidLessPos ?? 0}
    set {_forbidLessPos = newValue}
  }
  /// Returns true if `forbidLessPos` has been explicitly set.
  public var hasForbidLessPos: Bool {return self._forbidLessPos != nil}
  /// Clears the value of `forbidLessPos`. Subsequent reads from it will return its default value.
  public mutating func clearForbidLessPos() {self._forbidLessPos = nil}

  public var minSpacing: UInt64 {
    get {return _minSpacing ?? 0}
    set {_minSpacing = newValue}
  }
  /// Returns true if `minSpacing` has been explicitly set.
  public var hasMinSpacing: Bool {return self._minSpacing != nil}
  /// Clears the value of `minSpacing`. Subsequent reads from it will return its default value.
  public mutating func clearMinSpacing() {self._minSpacing = nil}

  public var forbidGreaterPos: UInt64 {
    get {return _forbidGreaterPos ?? 0}
    set {_forbidGreaterPos = newValue}
  }
  /// Returns true if `forbidGreaterPos` has been explicitly set.
  public var hasForbidGreaterPos: Bool {return self._forbidGreaterPos != nil}
  /// Clears the value of `forbidGreaterPos`. Subsequent reads from it will return its default value.
  public mutating func clearForbidGreaterPos() {self._forbidGreaterPos = nil}

  public var maxCount: UInt64 {
    get {return _maxCount ?? 0}
    set {_maxCount = newValue}
  }
  /// Returns true if `maxCount` has been explicitly set.
  public var hasMaxCount: Bool {return self._maxCount != nil}
  /// Clears the value of `maxCount`. Subsequent reads from it will return its default value.
  public mutating func clearMaxCount() {self._maxCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pluckPct: Double? = nil
  fileprivate var _forbidLessPos: UInt64? = nil
  fileprivate var _minSpacing: UInt64? = nil
  fileprivate var _forbidGreaterPos: UInt64? = nil
  fileprivate var _maxCount: UInt64? = nil
}

/// Next ID = 2.
public struct Delivery_DiversityRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var multi: Double {
    get {return _multi ?? 0}
    set {_multi = newValue}
  }
  /// Returns true if `multi` has been explicitly set.
  public var hasMulti: Bool {return self._multi != nil}
  /// Clears the value of `multi`. Subsequent reads from it will return its default value.
  public mutating func clearMulti() {self._multi = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _multi: Double? = nil
}

/// Next ID = 3.
public struct Delivery_BlenderConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of blender rules.
  public var blenderRule: [Delivery_BlenderRule] = []

  public var qualityScoreConfig: Delivery_QualityScoreConfig {
    get {return _qualityScoreConfig ?? Delivery_QualityScoreConfig()}
    set {_qualityScoreConfig = newValue}
  }
  /// Returns true if `qualityScoreConfig` has been explicitly set.
  public var hasQualityScoreConfig: Bool {return self._qualityScoreConfig != nil}
  /// Clears the value of `qualityScoreConfig`. Subsequent reads from it will return its default value.
  public mutating func clearQualityScoreConfig() {self._qualityScoreConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _qualityScoreConfig: Delivery_QualityScoreConfig? = nil
}

/// See: https://github.com/promotedai/qualityscore
/// Next ID = 2.
public struct Delivery_QualityScoreConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var weightedSumTerm: [Delivery_QualityScoreTerm] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Next ID = 14.
public struct Delivery_QualityScoreTerm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// How to fetch the base values of this term vector.
  public var fetchMethod: Delivery_QualityScoreTerm.OneOf_FetchMethod? = nil

  /// A named vector provided from elsewhere.
  public var attributeName: String {
    get {
      if case .attributeName(let v)? = fetchMethod {return v}
      return String()
    }
    set {fetchMethod = .attributeName(newValue)}
  }

  /// Randomly generated values from a normal distribution.
  public var randomNormal: Delivery_NormalDistribution {
    get {
      if case .randomNormal(let v)? = fetchMethod {return v}
      return Delivery_NormalDistribution()
    }
    set {fetchMethod = .randomNormal(newValue)}
  }

  /// A constant value of ones. Set to any constant with offset and/or weight.
  /// Set to "true" to indicate that this option is set by convention.
  public var ones: Bool {
    get {
      if case .ones(let v)? = fetchMethod {return v}
      return false
    }
    set {fetchMethod = .ones(newValue)}
  }

  /// Maximum limit of underlying value (before weight and offset).
  public var fetchHigh: Double {
    get {return _fetchHigh ?? 0}
    set {_fetchHigh = newValue}
  }
  /// Returns true if `fetchHigh` has been explicitly set.
  public var hasFetchHigh: Bool {return self._fetchHigh != nil}
  /// Clears the value of `fetchHigh`. Subsequent reads from it will return its default value.
  public mutating func clearFetchHigh() {self._fetchHigh = nil}

  /// Minimum limit of underlying value (before weight and offset).
  public var fetchLow: Double {
    get {return _fetchLow ?? 0}
    set {_fetchLow = newValue}
  }
  /// Returns true if `fetchLow` has been explicitly set.
  public var hasFetchLow: Bool {return self._fetchLow != nil}
  /// Clears the value of `fetchLow`. Subsequent reads from it will return its default value.
  public mutating func clearFetchLow() {self._fetchLow = nil}

  /// Multiply by this value. default =1 (no multiply).
  public var weight: Double = 0

  /// Add by this value. default = 0 (no addition)
  public var offset: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// How to fetch the base values of this term vector.
  public enum OneOf_FetchMethod: Equatable {
    /// A named vector provided from elsewhere.
    case attributeName(String)
    /// Randomly generated values from a normal distribution.
    case randomNormal(Delivery_NormalDistribution)
    /// A constant value of ones. Set to any constant with offset and/or weight.
    /// Set to "true" to indicate that this option is set by convention.
    case ones(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Delivery_QualityScoreTerm.OneOf_FetchMethod, rhs: Delivery_QualityScoreTerm.OneOf_FetchMethod) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.attributeName, .attributeName): return {
        guard case .attributeName(let l) = lhs, case .attributeName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomNormal, .randomNormal): return {
        guard case .randomNormal(let l) = lhs, case .randomNormal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ones, .ones): return {
        guard case .ones(let l) = lhs, case .ones(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _fetchHigh: Double? = nil
  fileprivate var _fetchLow: Double? = nil
}

/// Next ID = 3.
public struct Delivery_NormalDistribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mean: Double = 0

  public var variance: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "delivery"

extension Delivery_BlenderRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlenderRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_name"),
    6: .standard(proto: "positive_rule"),
    7: .standard(proto: "insert_rule"),
    8: .standard(proto: "negative_rule"),
    9: .standard(proto: "diversity_rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.attributeName) }()
      case 6: try {
        var v: Delivery_PositiveRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .positiveRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .positiveRule(v)
        }
      }()
      case 7: try {
        var v: Delivery_InsertRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .insertRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .insertRule(v)
        }
      }()
      case 8: try {
        var v: Delivery_NegativeRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .negativeRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .negativeRule(v)
        }
      }()
      case 9: try {
        var v: Delivery_DiversityRule?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .diversityRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .diversityRule(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attributeName.isEmpty {
      try visitor.visitSingularStringField(value: self.attributeName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.rule {
    case .positiveRule?: try {
      guard case .positiveRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .insertRule?: try {
      guard case .insertRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .negativeRule?: try {
      guard case .negativeRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .diversityRule?: try {
      guard case .diversityRule(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_BlenderRule, rhs: Delivery_BlenderRule) -> Bool {
    if lhs.attributeName != rhs.attributeName {return false}
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_PositiveRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositiveRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "select_pct"),
    2: .standard(proto: "min_pos"),
    3: .standard(proto: "max_pos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._selectPct) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._minPos) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxPos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._selectPct {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._minPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._maxPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_PositiveRule, rhs: Delivery_PositiveRule) -> Bool {
    if lhs._selectPct != rhs._selectPct {return false}
    if lhs._minPos != rhs._minPos {return false}
    if lhs._maxPos != rhs._maxPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_InsertRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InsertRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "select_pct"),
    2: .standard(proto: "min_pos"),
    3: .standard(proto: "max_pos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._selectPct) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._minPos) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxPos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._selectPct {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._minPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._maxPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_InsertRule, rhs: Delivery_InsertRule) -> Bool {
    if lhs._selectPct != rhs._selectPct {return false}
    if lhs._minPos != rhs._minPos {return false}
    if lhs._maxPos != rhs._maxPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_NegativeRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NegativeRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pluck_pct"),
    2: .standard(proto: "forbid_less_pos"),
    3: .standard(proto: "min_spacing"),
    4: .standard(proto: "forbid_greater_pos"),
    5: .standard(proto: "max_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._pluckPct) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._forbidLessPos) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._minSpacing) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._forbidGreaterPos) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._maxCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pluckPct {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._forbidLessPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._minSpacing {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._forbidGreaterPos {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._maxCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_NegativeRule, rhs: Delivery_NegativeRule) -> Bool {
    if lhs._pluckPct != rhs._pluckPct {return false}
    if lhs._forbidLessPos != rhs._forbidLessPos {return false}
    if lhs._minSpacing != rhs._minSpacing {return false}
    if lhs._forbidGreaterPos != rhs._forbidGreaterPos {return false}
    if lhs._maxCount != rhs._maxCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_DiversityRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiversityRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._multi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._multi {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_DiversityRule, rhs: Delivery_DiversityRule) -> Bool {
    if lhs._multi != rhs._multi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_BlenderConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlenderConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blender_rule"),
    2: .standard(proto: "quality_score_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blenderRule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._qualityScoreConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blenderRule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blenderRule, fieldNumber: 1)
    }
    if let v = self._qualityScoreConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_BlenderConfig, rhs: Delivery_BlenderConfig) -> Bool {
    if lhs.blenderRule != rhs.blenderRule {return false}
    if lhs._qualityScoreConfig != rhs._qualityScoreConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_QualityScoreConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QualityScoreConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weighted_sum_term"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.weightedSumTerm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weightedSumTerm.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weightedSumTerm, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_QualityScoreConfig, rhs: Delivery_QualityScoreConfig) -> Bool {
    if lhs.weightedSumTerm != rhs.weightedSumTerm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_QualityScoreTerm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QualityScoreTerm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_name"),
    2: .standard(proto: "random_normal"),
    3: .same(proto: "ones"),
    10: .standard(proto: "fetch_high"),
    11: .standard(proto: "fetch_low"),
    12: .same(proto: "weight"),
    13: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.fetchMethod != nil {try decoder.handleConflictingOneOf()}
          self.fetchMethod = .attributeName(v)
        }
      }()
      case 2: try {
        var v: Delivery_NormalDistribution?
        var hadOneofValue = false
        if let current = self.fetchMethod {
          hadOneofValue = true
          if case .randomNormal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.fetchMethod = .randomNormal(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.fetchMethod != nil {try decoder.handleConflictingOneOf()}
          self.fetchMethod = .ones(v)
        }
      }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self._fetchHigh) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self._fetchLow) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self.weight) }()
      case 13: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.fetchMethod {
    case .attributeName?: try {
      guard case .attributeName(let v)? = self.fetchMethod else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .randomNormal?: try {
      guard case .randomNormal(let v)? = self.fetchMethod else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ones?: try {
      guard case .ones(let v)? = self.fetchMethod else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if let v = self._fetchHigh {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
    }
    if let v = self._fetchLow {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 11)
    }
    if self.weight != 0 {
      try visitor.visitSingularDoubleField(value: self.weight, fieldNumber: 12)
    }
    if self.offset != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_QualityScoreTerm, rhs: Delivery_QualityScoreTerm) -> Bool {
    if lhs.fetchMethod != rhs.fetchMethod {return false}
    if lhs._fetchHigh != rhs._fetchHigh {return false}
    if lhs._fetchLow != rhs._fetchLow {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Delivery_NormalDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NormalDistribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mean"),
    2: .same(proto: "variance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.mean) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.variance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mean != 0 {
      try visitor.visitSingularDoubleField(value: self.mean, fieldNumber: 1)
    }
    if self.variance != 0 {
      try visitor.visitSingularDoubleField(value: self.variance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Delivery_NormalDistribution, rhs: Delivery_NormalDistribution) -> Bool {
    if lhs.mean != rhs.mean {return false}
    if lhs.variance != rhs.variance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
