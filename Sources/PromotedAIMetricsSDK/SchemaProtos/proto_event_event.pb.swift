// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/event/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The arm (experiment's group) when the Cohort is for an experiment.
/// Next ID = 6.
public enum Event_CohortArm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownGroup // = 0
  case control // = 1
  case treatment // = 2

  /// These are generic arms (groups) that can be used when there are multiple treatments.
  case treatment1 // = 3
  case treatment2 // = 4
  case treatment3 // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownGroup
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownGroup
    case 1: self = .control
    case 2: self = .treatment
    case 3: self = .treatment1
    case 4: self = .treatment2
    case 5: self = .treatment3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownGroup: return 0
    case .control: return 1
    case .treatment: return 2
    case .treatment1: return 3
    case .treatment2: return 4
    case .treatment3: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_CohortArm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_CohortArm] = [
    .unknownGroup,
    .control,
    .treatment,
    .treatment1,
    .treatment2,
    .treatment3,
  ]
}

#endif  // swift(>=4.2)

/// Next ID = 4.
public enum Event_DeviceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownDeviceType // = 0
  case desktop // = 1
  case mobile // = 2
  case tablet // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownDeviceType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDeviceType
    case 1: self = .desktop
    case 2: self = .mobile
    case 3: self = .tablet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownDeviceType: return 0
    case .desktop: return 1
    case .mobile: return 2
    case .tablet: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_DeviceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_DeviceType] = [
    .unknownDeviceType,
    .desktop,
    .mobile,
    .tablet,
  ]
}

#endif  // swift(>=4.2)

/// The action that user wants to perform.
///
/// Next ID = 8.
public enum Event_ActionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownActionType // = 0

  /// Action that doesn't correspond to any of the below.
  case customActionType // = 1

  /// Navigating to details about content.
  case navigate // = 2

  /// Purchasing an item.
  case purchase // = 3

  /// Adding an item to shopping cart.
  case addToCart // = 4

  /// Sharing content.
  case share // = 5

  /// Liking content.
  case like // = 6

  /// Commenting on content.
  case comment // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownActionType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownActionType
    case 1: self = .customActionType
    case 2: self = .navigate
    case 3: self = .purchase
    case 4: self = .addToCart
    case 5: self = .share
    case 6: self = .like
    case 7: self = .comment
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownActionType: return 0
    case .customActionType: return 1
    case .navigate: return 2
    case .purchase: return 3
    case .addToCart: return 4
    case .share: return 5
    case .like: return 6
    case .comment: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_ActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_ActionType] = [
    .unknownActionType,
    .customActionType,
    .navigate,
    .purchase,
    .addToCart,
    .share,
    .like,
    .comment,
  ]
}

#endif  // swift(>=4.2)

/// This structure is used to help deduplicate identifiers that live in many
/// event types.
/// Next ID = 9.
public struct Event_JoinedIdentifiers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformID: UInt64 = 0

  public var userID: String = String()

  public var logUserID: String = String()

  public var sessionID: String = String()

  public var viewID: String = String()

  public var requestID: String = String()

  public var insertionID: String = String()

  public var impressionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to store user properties.  E.g. purchasedContentIds.
/// Clients can update each User multiple times by logging the User with the same
/// user_id.  Unset fields will not be updated. Repeated fields will act like a
/// merge if the item has a key.  Otherwise, it'll act like an append.
///
/// TODO - when we want this on Request, move this to delivery.
/// Next ID = 7.
public struct Event_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// For linking users to cohorts.
/// Next ID = 11.
public struct Event_CohortMembership {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Optional.  This can contain a log UUID to help track down log records.
  public var membershipID: String = String()

  /// Optional.  This field refers to the cohort (currently stored as an enum).
  public var cohortID: String = String()

  /// Optional.
  public var arm: Event_CohortArm = .unknownGroup

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// Locale for session
/// Next ID = 3.
public struct Event_Locale {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "en", "zh_Hant", "fr"
  public var languageCode: String = String()

  /// "US", "CA", "FR"
  public var regionCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Rectangle size in pixels
/// Next ID = 3.
public struct Event_Size {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: UInt32 = 0

  public var height: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device screen
/// Next ID = 3.
public struct Event_Screen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Android: DisplayMetrics.widthPixels/heightPixels
  /// iOS: UIScreen.nativeBounds.width/height
  public var size: Event_Size {
    get {return _size ?? Event_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  /// Natural scale factor.
  /// Android: DisplayMetrics.density
  /// iOS: UIScreen.scale
  public var scale: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _size: Event_Size? = nil
}

/// A sub-message containing Device info.
/// Next ID = 8.
public struct Event_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceType: Event_DeviceType = .unknownDeviceType

  /// Android: android.os.Build.BRAND
  ///          (eg. "google", "verizon", "tmobile", "Samsung")
  /// iOS: "Apple"
  public var brand: String = String()

  /// Android: android.os.Build.MANUFACTURER
  ///          (eg. "HTC", "Motorola", "HUAWEI")
  /// iOS: "Apple"
  public var manufacturer: String = String()

  /// Android: android.os.Build.MODEL
  ///          (eg. "GT-S5830L", "MB860")
  /// iOS: "iPhoneXX,YY" or "iPadXX,YY"
  public var identifier: String = String()

  /// Android: android.os.Build.VERSION.RELEASE
  /// iOS: "14.4.1"
  public var osVersion: String = String()

  public var locale: Event_Locale {
    get {return _locale ?? Event_Locale()}
    set {_locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return self._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {self._locale = nil}

  public var screen: Event_Screen {
    get {return _screen ?? Event_Screen()}
    set {_screen = newValue}
  }
  /// Returns true if `screen` has been explicitly set.
  public var hasScreen: Bool {return self._screen != nil}
  /// Clears the value of `screen`. Subsequent reads from it will return its default value.
  public mutating func clearScreen() {self._screen = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _locale: Event_Locale? = nil
  fileprivate var _screen: Event_Screen? = nil
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// A newer alternative to user agent strings.
public struct Event_ClientHints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isMobile: Bool = false

  public var brand: [Event_ClientHintBrand] = []

  public var architecture: String = String()

  public var model: String = String()

  public var platform: String = String()

  public var platformVersion: String = String()

  public var uaFullVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// a part of ClientHints.
public struct Event_ClientHintBrand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var brand: String = String()

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A sub-message containing Browser info.
/// Next ID = 4.
public struct Event_Browser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAgent: String = String()

  public var viewportSize: Event_Size {
    get {return _viewportSize ?? Event_Size()}
    set {_viewportSize = newValue}
  }
  /// Returns true if `viewportSize` has been explicitly set.
  public var hasViewportSize: Bool {return self._viewportSize != nil}
  /// Clears the value of `viewportSize`. Subsequent reads from it will return its default value.
  public mutating func clearViewportSize() {self._viewportSize = nil}

  public var clientHints: Event_ClientHints {
    get {return _clientHints ?? Event_ClientHints()}
    set {_clientHints = newValue}
  }
  /// Returns true if `clientHints` has been explicitly set.
  public var hasClientHints: Bool {return self._clientHints != nil}
  /// Clears the value of `clientHints`. Subsequent reads from it will return its default value.
  public mutating func clearClientHints() {self._clientHints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _viewportSize: Event_Size? = nil
  fileprivate var _clientHints: Event_ClientHints? = nil
}

/// Next ID = 3.
public struct Event_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [-90, 90]
  public var latitude: Double = 0

  /// [-180, 180]
  public var longitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ** Not currently used **
/// Profile (contains pii) version of Session.
/// Next ID = 9.
public struct Event_SessionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Required. This is the primary ID.
  public var sessionID: String = String()

  /// Optional.
  public var location: Event_Location {
    get {return _location ?? Event_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _location: Event_Location? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// ** Not currently used **
/// A period of activity by a single User.  Users can have multiple Sessions.
/// Clients can update a Session multiple times by logging multiple Sessions with
/// the same session_id.  Unset fields will not be updated.  Repeated fields will
/// act like a merge if the item has a key.  Otherwise, it'll act like an append.
/// Next ID = 10.
public struct Event_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Required. This is the primary ID.
  public var sessionID: String = String()

  /// Optional. Start time. If not set, we'll infer this from the API calls.
  public var startEpochMillis: UInt64 = 0

  /// Optional. End time. If not set, we'll infer this from the API calls.
  public var exclusiveEndEpochMillis: UInt64 = 0

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// Submessage on View for Web page visits.
/// Next ID = 5.
public struct Event_WebPageView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  This is the url for the page.
  public var url: String = String()

  /// Optional.
  public var browser: Event_Browser {
    get {return _browser ?? Event_Browser()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  /// Optional.  Can be a full referrer string.  Could be just the UTM.
  public var referrer: String = String()

  public var documentSize: Event_Size {
    get {return _documentSize ?? Event_Size()}
    set {_documentSize = newValue}
  }
  /// Returns true if `documentSize` has been explicitly set.
  public var hasDocumentSize: Bool {return self._documentSize != nil}
  /// Clears the value of `documentSize`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentSize() {self._documentSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _browser: Event_Browser? = nil
  fileprivate var _documentSize: Event_Size? = nil
}

/// Submessage on View for screen views.
/// Next ID = 1.
public struct Event_AppScreenView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A view of a single page/screen (e.g. feed, search results, etc).
///
/// TODO - when we want this on Request, move this to delivery.
/// Next ID = 16.
public struct Event_View {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Required.  This is a UUID that is generated by the client.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional.  The name of the view.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.
  public var useCase: Delivery_UseCase {
    get {return _storage._useCase}
    set {_uniqueStorage()._useCase = newValue}
  }

  /// Optional.
  public var searchQuery: String {
    get {return _storage._searchQuery}
    set {_uniqueStorage()._searchQuery = newValue}
  }

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  /// Optional.
  public var device: Event_Device {
    get {return _storage._device ?? Event_Device()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {_uniqueStorage()._device = nil}

  /// Next ID = 5.
  public var viewType: Event_View.ViewType {
    get {return _storage._viewType}
    set {_uniqueStorage()._viewType = newValue}
  }

  public var uiType: OneOf_UiType? {
    get {return _storage._uiType}
    set {_uniqueStorage()._uiType = newValue}
  }

  public var webPageView: Event_WebPageView {
    get {
      if case .webPageView(let v)? = _storage._uiType {return v}
      return Event_WebPageView()
    }
    set {_uniqueStorage()._uiType = .webPageView(newValue)}
  }

  public var appScreenView: Event_AppScreenView {
    get {
      if case .appScreenView(let v)? = _storage._uiType {return v}
      return Event_AppScreenView()
    }
    set {_uniqueStorage()._uiType = .appScreenView(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_UiType: Equatable {
    case webPageView(Event_WebPageView)
    case appScreenView(Event_AppScreenView)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_View.OneOf_UiType, rhs: Event_View.OneOf_UiType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.webPageView, .webPageView): return {
        guard case .webPageView(let l) = lhs, case .webPageView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appScreenView, .appScreenView): return {
        guard case .appScreenView(let l) = lhs, case .appScreenView(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ViewType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownViewType // = 0
    case webPage // = 1
    case appScreen // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownViewType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownViewType
      case 1: self = .webPage
      case 2: self = .appScreen
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownViewType: return 0
      case .webPage: return 1
      case .appScreen: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Event_View.ViewType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_View.ViewType] = [
    .unknownViewType,
    .webPage,
    .appScreen,
  ]
}

#endif  // swift(>=4.2)

/// When an Insertion (instance of Content) is shown to a user.
/// Impressions are immutable.
/// Next ID = 12.
public struct Event_Impression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Required.  This is a UUID that is generated by the client.
  public var impressionID: String = String()

  /// Optional.
  public var insertionID: String = String()

  /// Optional.
  public var requestID: String = String()

  /// Optional.
  public var viewID: String = String()

  /// Optional.
  public var sessionID: String = String()

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _properties ?? Common_Properties()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
  fileprivate var _properties: Common_Properties? = nil
}

/// Next ID = 2.
public struct Event_NavigateAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  The next URL.
  public var targetURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Actions are user actions.  Example: Click.
/// Actions are immutable.
/// Next ID = 21.
public struct Event_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.platform_id.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Optional.  Must be set on LogRequest or here.
  public var userInfo: Common_UserInfo {
    get {return _storage._userInfo ?? Common_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses LogRequest.timing.
  public var timing: Common_Timing {
    get {return _storage._timing ?? Common_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Required.  This is a UUID for the click.
  public var actionID: String {
    get {return _storage._actionID}
    set {_uniqueStorage()._actionID = newValue}
  }

  /// Optional.
  public var impressionID: String {
    get {return _storage._impressionID}
    set {_uniqueStorage()._impressionID = newValue}
  }

  /// Optional.
  public var insertionID: String {
    get {return _storage._insertionID}
    set {_uniqueStorage()._insertionID = newValue}
  }

  /// Optional.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Optional.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional.  Custom name of the action that the user performed.
  /// E.g. "Product clicked".  Do not stick parameters or pii in this name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.  The action that the user wants to perform.
  public var actionType: Event_ActionType {
    get {return _storage._actionType}
    set {_uniqueStorage()._actionType = newValue}
  }

  /// Optional.
  public var customActionType: String {
    get {return _storage._customActionType}
    set {_uniqueStorage()._customActionType = newValue}
  }

  public var elementID: String {
    get {return _storage._elementID}
    set {_uniqueStorage()._elementID = newValue}
  }

  public var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// TODO - add PURCHASE details.
  /// TODO - add ADD_TO_CART details.
  /// TODO - add SHARE details.
  /// TODO - add LIKE details.
  /// TODO - add COMMENT details.
  public var navigateAction: Event_NavigateAction {
    get {
      if case .navigateAction(let v)? = _storage._action {return v}
      return Event_NavigateAction()
    }
    set {_uniqueStorage()._action = .navigateAction(newValue)}
  }

  /// Optional.  Custom properties per platform.
  public var properties: Common_Properties {
    get {return _storage._properties ?? Common_Properties()}
    set {_uniqueStorage()._properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return _storage._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {_uniqueStorage()._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    /// TODO - add PURCHASE details.
    /// TODO - add ADD_TO_CART details.
    /// TODO - add SHARE details.
    /// TODO - add LIKE details.
    /// TODO - add COMMENT details.
    case navigateAction(Event_NavigateAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_Action.OneOf_Action, rhs: Event_Action.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.navigateAction, .navigateAction): return {
        guard case .navigateAction(let l) = lhs, case .navigateAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Contains a list of recent impressions for a flat event.
/// The list is wrapped in this message so (1) we can differentiate between null
/// and zero and (2) we can add more fields later.
/// For Promoted-internal use only.
/// Next ID = 2.
public struct Event_LatestImpressions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ordered with latest impressions at the end of the repeated list.
  public var impression: [Event_LatestImpression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A smaller Impression to be used on LatestImpressions.
/// For Promoted-internal use only.
/// Next ID = 6.
public struct Event_LatestImpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var impressionID: String = String()

  public var contentID: String = String()

  /// Optional.  Depends on if the client sets it.  This can be impacted by
  /// client clock skew.
  public var clientLogTimestamp: UInt64 = 0

  /// Required.  Generated in Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Required.  This is the event timestamp in our stream job (currently the
  /// Kafka insertion timestamp).
  public var eventTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A way to batch up log requests into the same request.
/// Clients can reference logs in different batches.
/// Next ID = 17.
public struct Event_LogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses the value set on each log record.
  public var platformID: UInt64 = 0

  /// Optional.  Must be set on each child log record or here.
  public var userInfo: Common_UserInfo {
    get {return _userInfo ?? Common_UserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// Optional.  If not set, set by API servers.
  /// If not set, API server uses the value set on each log record.
  public var timing: Common_Timing {
    get {return _timing ?? Common_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  public var user: [Event_User] = []

  public var cohortMembership: [Event_CohortMembership] = []

  public var sessionProfile: [Event_SessionProfile] = []

  public var session: [Event_Session] = []

  public var view: [Event_View] = []

  public var request: [Delivery_Request] = []

  public var insertion: [Delivery_Insertion] = []

  public var impression: [Event_Impression] = []

  public var action: [Event_Action] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: Common_UserInfo? = nil
  fileprivate var _timing: Common_Timing? = nil
}

/// Internal Proto used for flattened events.
/// Keep proto IDs matching LogRequest.
/// Next ID = 17.
public struct Event_FlatEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: Event_JoinedIdentifiers {
    get {return _storage._ids ?? Event_JoinedIdentifiers()}
    set {_uniqueStorage()._ids = newValue}
  }
  /// Returns true if `ids` has been explicitly set.
  public var hasIds: Bool {return _storage._ids != nil}
  /// Clears the value of `ids`. Subsequent reads from it will return its default value.
  public mutating func clearIds() {_uniqueStorage()._ids = nil}

  public var user: Event_User {
    get {return _storage._user ?? Event_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var sessionProfile: Event_SessionProfile {
    get {return _storage._sessionProfile ?? Event_SessionProfile()}
    set {_uniqueStorage()._sessionProfile = newValue}
  }
  /// Returns true if `sessionProfile` has been explicitly set.
  public var hasSessionProfile: Bool {return _storage._sessionProfile != nil}
  /// Clears the value of `sessionProfile`. Subsequent reads from it will return its default value.
  public mutating func clearSessionProfile() {_uniqueStorage()._sessionProfile = nil}

  public var session: Event_Session {
    get {return _storage._session ?? Event_Session()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {_uniqueStorage()._session = nil}

  public var view: Event_View {
    get {return _storage._view ?? Event_View()}
    set {_uniqueStorage()._view = newValue}
  }
  /// Returns true if `view` has been explicitly set.
  public var hasView: Bool {return _storage._view != nil}
  /// Clears the value of `view`. Subsequent reads from it will return its default value.
  public mutating func clearView() {_uniqueStorage()._view = nil}

  public var request: Delivery_Request {
    get {return _storage._request ?? Delivery_Request()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {_uniqueStorage()._request = nil}

  public var insertion: Delivery_Insertion {
    get {return _storage._insertion ?? Delivery_Insertion()}
    set {_uniqueStorage()._insertion = newValue}
  }
  /// Returns true if `insertion` has been explicitly set.
  public var hasInsertion: Bool {return _storage._insertion != nil}
  /// Clears the value of `insertion`. Subsequent reads from it will return its default value.
  public mutating func clearInsertion() {_uniqueStorage()._insertion = nil}

  public var impression: Event_Impression {
    get {return _storage._impression ?? Event_Impression()}
    set {_uniqueStorage()._impression = newValue}
  }
  /// Returns true if `impression` has been explicitly set.
  public var hasImpression: Bool {return _storage._impression != nil}
  /// Clears the value of `impression`. Subsequent reads from it will return its default value.
  public mutating func clearImpression() {_uniqueStorage()._impression = nil}

  public var action: Event_Action {
    get {return _storage._action ?? Event_Action()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {_uniqueStorage()._action = nil}

  /// For Promoted-internal use only.
  public var latestImpressions: Event_LatestImpressions {
    get {return _storage._latestImpressions ?? Event_LatestImpressions()}
    set {_uniqueStorage()._latestImpressions = newValue}
  }
  /// Returns true if `latestImpressions` has been explicitly set.
  public var hasLatestImpressions: Bool {return _storage._latestImpressions != nil}
  /// Clears the value of `latestImpressions`. Subsequent reads from it will return its default value.
  public mutating func clearLatestImpressions() {_uniqueStorage()._latestImpressions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "event"

extension Event_CohortArm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_GROUP"),
    1: .same(proto: "CONTROL"),
    2: .same(proto: "TREATMENT"),
    3: .same(proto: "TREATMENT1"),
    4: .same(proto: "TREATMENT2"),
    5: .same(proto: "TREATMENT3"),
  ]
}

extension Event_DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DEVICE_TYPE"),
    1: .same(proto: "DESKTOP"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "TABLET"),
  ]
}

extension Event_ActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTION_TYPE"),
    1: .same(proto: "CUSTOM_ACTION_TYPE"),
    2: .same(proto: "NAVIGATE"),
    3: .same(proto: "PURCHASE"),
    4: .same(proto: "ADD_TO_CART"),
    5: .same(proto: "SHARE"),
    6: .same(proto: "LIKE"),
    7: .same(proto: "COMMENT"),
  ]
}

extension Event_JoinedIdentifiers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinedIdentifiers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "session_id"),
    5: .standard(proto: "view_id"),
    6: .standard(proto: "request_id"),
    7: .standard(proto: "insertion_id"),
    8: .standard(proto: "impression_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 7)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_JoinedIdentifiers, rhs: Event_JoinedIdentifiers) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    6: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_User, rhs: Event_User) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_CohortMembership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CohortMembership"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    6: .standard(proto: "membership_id"),
    8: .standard(proto: "cohort_id"),
    9: .same(proto: "arm"),
    10: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.membershipID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cohortID) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.arm) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.membershipID.isEmpty {
      try visitor.visitSingularStringField(value: self.membershipID, fieldNumber: 6)
    }
    if !self.cohortID.isEmpty {
      try visitor.visitSingularStringField(value: self.cohortID, fieldNumber: 8)
    }
    if self.arm != .unknownGroup {
      try visitor.visitSingularEnumField(value: self.arm, fieldNumber: 9)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_CohortMembership, rhs: Event_CohortMembership) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.membershipID != rhs.membershipID {return false}
    if lhs.cohortID != rhs.cohortID {return false}
    if lhs.arm != rhs.arm {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Locale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Locale"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "language_code"),
    2: .standard(proto: "region_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Locale, rhs: Event_Locale) -> Bool {
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Size"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Size, rhs: Event_Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Screen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Screen, rhs: Event_Screen) -> Bool {
    if lhs._size != rhs._size {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_type"),
    2: .same(proto: "brand"),
    3: .same(proto: "manufacturer"),
    4: .same(proto: "identifier"),
    5: .standard(proto: "os_version"),
    6: .same(proto: "locale"),
    7: .same(proto: "screen"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.manufacturer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._locale) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceType != .unknownDeviceType {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 1)
    }
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 2)
    }
    if !self.manufacturer.isEmpty {
      try visitor.visitSingularStringField(value: self.manufacturer, fieldNumber: 3)
    }
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if let v = self._locale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Device, rhs: Event_Device) -> Bool {
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.manufacturer != rhs.manufacturer {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs._locale != rhs._locale {return false}
    if lhs._screen != rhs._screen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ClientHints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_mobile"),
    2: .same(proto: "brand"),
    3: .same(proto: "architecture"),
    4: .same(proto: "model"),
    5: .same(proto: "platform"),
    6: .standard(proto: "platform_version"),
    7: .standard(proto: "ua_full_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isMobile) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.brand) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.platformVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.uaFullVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMobile != false {
      try visitor.visitSingularBoolField(value: self.isMobile, fieldNumber: 1)
    }
    if !self.brand.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.brand, fieldNumber: 2)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 3)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 4)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 5)
    }
    if !self.platformVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.platformVersion, fieldNumber: 6)
    }
    if !self.uaFullVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.uaFullVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ClientHints, rhs: Event_ClientHints) -> Bool {
    if lhs.isMobile != rhs.isMobile {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.model != rhs.model {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.platformVersion != rhs.platformVersion {return false}
    if lhs.uaFullVersion != rhs.uaFullVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ClientHintBrand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHintBrand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brand"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ClientHintBrand, rhs: Event_ClientHintBrand) -> Bool {
    if lhs.brand != rhs.brand {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Browser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Browser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_agent"),
    2: .standard(proto: "viewport_size"),
    3: .standard(proto: "client_hints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._viewportSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientHints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 1)
    }
    if let v = self._viewportSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._clientHints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Browser, rhs: Event_Browser) -> Bool {
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs._viewportSize != rhs._viewportSize {return false}
    if lhs._clientHints != rhs._clientHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Location, rhs: Event_Location) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_SessionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    6: .standard(proto: "session_id"),
    7: .same(proto: "location"),
    8: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 6)
    }
    if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_SessionProfile, rhs: Event_SessionProfile) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs._location != rhs._location {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Session"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    6: .standard(proto: "session_id"),
    7: .standard(proto: "start_epoch_millis"),
    8: .standard(proto: "exclusive_end_epoch_millis"),
    9: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.startEpochMillis) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.exclusiveEndEpochMillis) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 6)
    }
    if self.startEpochMillis != 0 {
      try visitor.visitSingularUInt64Field(value: self.startEpochMillis, fieldNumber: 7)
    }
    if self.exclusiveEndEpochMillis != 0 {
      try visitor.visitSingularUInt64Field(value: self.exclusiveEndEpochMillis, fieldNumber: 8)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Session, rhs: Event_Session) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.startEpochMillis != rhs.startEpochMillis {return false}
    if lhs.exclusiveEndEpochMillis != rhs.exclusiveEndEpochMillis {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_WebPageView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebPageView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "browser"),
    3: .same(proto: "referrer"),
    4: .standard(proto: "document_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.referrer) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._documentSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.referrer.isEmpty {
      try visitor.visitSingularStringField(value: self.referrer, fieldNumber: 3)
    }
    if let v = self._documentSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_WebPageView, rhs: Event_WebPageView) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs.referrer != rhs.referrer {return false}
    if lhs._documentSize != rhs._documentSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_AppScreenView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppScreenView"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_AppScreenView, rhs: Event_AppScreenView) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".View"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    6: .standard(proto: "view_id"),
    7: .standard(proto: "session_id"),
    8: .same(proto: "name"),
    9: .standard(proto: "use_case"),
    10: .standard(proto: "search_query"),
    11: .same(proto: "properties"),
    12: .same(proto: "device"),
    13: .standard(proto: "view_type"),
    14: .standard(proto: "web_page_view"),
    15: .standard(proto: "app_screen_view"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _viewID: String = String()
    var _sessionID: String = String()
    var _name: String = String()
    var _useCase: Delivery_UseCase = .unknownUseCase
    var _searchQuery: String = String()
    var _properties: Common_Properties? = nil
    var _device: Event_Device? = nil
    var _viewType: Event_View.ViewType = .unknownViewType
    var _uiType: Event_View.OneOf_UiType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _viewID = source._viewID
      _sessionID = source._sessionID
      _name = source._name
      _useCase = source._useCase
      _searchQuery = source._searchQuery
      _properties = source._properties
      _device = source._device
      _viewType = source._viewType
      _uiType = source._uiType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._useCase) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._searchQuery) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._viewType) }()
        case 14: try {
          var v: Event_WebPageView?
          if let current = _storage._uiType {
            try decoder.handleConflictingOneOf()
            if case .webPageView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._uiType = .webPageView(v)}
        }()
        case 15: try {
          var v: Event_AppScreenView?
          if let current = _storage._uiType {
            try decoder.handleConflictingOneOf()
            if case .appScreenView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._uiType = .appScreenView(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 6)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 7)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      if _storage._useCase != .unknownUseCase {
        try visitor.visitSingularEnumField(value: _storage._useCase, fieldNumber: 9)
      }
      if !_storage._searchQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._searchQuery, fieldNumber: 10)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._viewType != .unknownViewType {
        try visitor.visitSingularEnumField(value: _storage._viewType, fieldNumber: 13)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._uiType {
      case .webPageView?: try {
        guard case .webPageView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .appScreenView?: try {
        guard case .appScreenView(let v)? = _storage._uiType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_View, rhs: Event_View) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._useCase != rhs_storage._useCase {return false}
        if _storage._searchQuery != rhs_storage._searchQuery {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._viewType != rhs_storage._viewType {return false}
        if _storage._uiType != rhs_storage._uiType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View.ViewType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VIEW_TYPE"),
    1: .same(proto: "WEB_PAGE"),
    2: .same(proto: "APP_SCREEN"),
  ]
}

extension Event_Impression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Impression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    6: .standard(proto: "impression_id"),
    7: .standard(proto: "insertion_id"),
    8: .standard(proto: "request_id"),
    10: .standard(proto: "view_id"),
    9: .standard(proto: "session_id"),
    11: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 6)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 7)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 8)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 9)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 10)
    }
    if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Impression, rhs: Event_Impression) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_NavigateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NavigateAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetURL.isEmpty {
      try visitor.visitSingularStringField(value: self.targetURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_NavigateAction, rhs: Event_NavigateAction) -> Bool {
    if lhs.targetURL != rhs.targetURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    6: .standard(proto: "action_id"),
    7: .standard(proto: "impression_id"),
    8: .standard(proto: "insertion_id"),
    9: .standard(proto: "request_id"),
    11: .standard(proto: "view_id"),
    10: .standard(proto: "session_id"),
    12: .same(proto: "name"),
    14: .standard(proto: "action_type"),
    15: .standard(proto: "custom_action_type"),
    17: .standard(proto: "element_id"),
    18: .standard(proto: "navigate_action"),
    20: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _userInfo: Common_UserInfo? = nil
    var _timing: Common_Timing? = nil
    var _actionID: String = String()
    var _impressionID: String = String()
    var _insertionID: String = String()
    var _requestID: String = String()
    var _viewID: String = String()
    var _sessionID: String = String()
    var _name: String = String()
    var _actionType: Event_ActionType = .unknownActionType
    var _customActionType: String = String()
    var _elementID: String = String()
    var _action: Event_Action.OneOf_Action?
    var _properties: Common_Properties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _userInfo = source._userInfo
      _timing = source._timing
      _actionID = source._actionID
      _impressionID = source._impressionID
      _insertionID = source._insertionID
      _requestID = source._requestID
      _viewID = source._viewID
      _sessionID = source._sessionID
      _name = source._name
      _actionType = source._actionType
      _customActionType = source._customActionType
      _elementID = source._elementID
      _action = source._action
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._actionID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._impressionID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._insertionID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._actionType) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._customActionType) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._elementID) }()
        case 18: try {
          var v: Event_NavigateAction?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .navigateAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .navigateAction(v)}
        }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._properties) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._actionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionID, fieldNumber: 6)
      }
      if !_storage._impressionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._impressionID, fieldNumber: 7)
      }
      if !_storage._insertionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._insertionID, fieldNumber: 8)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 9)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 10)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 11)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 12)
      }
      if _storage._actionType != .unknownActionType {
        try visitor.visitSingularEnumField(value: _storage._actionType, fieldNumber: 14)
      }
      if !_storage._customActionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customActionType, fieldNumber: 15)
      }
      if !_storage._elementID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._elementID, fieldNumber: 17)
      }
      if case .navigateAction(let v)? = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._properties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Action, rhs: Event_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._actionID != rhs_storage._actionID {return false}
        if _storage._impressionID != rhs_storage._impressionID {return false}
        if _storage._insertionID != rhs_storage._insertionID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._actionType != rhs_storage._actionType {return false}
        if _storage._customActionType != rhs_storage._customActionType {return false}
        if _storage._elementID != rhs_storage._elementID {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LatestImpressions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestImpressions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "impression"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.impression) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.impression.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.impression, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LatestImpressions, rhs: Event_LatestImpressions) -> Bool {
    if lhs.impression != rhs.impression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LatestImpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestImpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "impression_id"),
    2: .standard(proto: "content_id"),
    3: .standard(proto: "client_log_timestamp"),
    4: .standard(proto: "event_api_timestamp"),
    5: .standard(proto: "event_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 1)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 2)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 3)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 4)
    }
    if self.eventTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventTimestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LatestImpression, rhs: Event_LatestImpression) -> Bool {
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.eventTimestamp != rhs.eventTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_info"),
    3: .same(proto: "timing"),
    7: .same(proto: "user"),
    8: .standard(proto: "cohort_membership"),
    9: .standard(proto: "session_profile"),
    10: .same(proto: "session"),
    11: .same(proto: "view"),
    12: .same(proto: "request"),
    13: .same(proto: "insertion"),
    14: .same(proto: "impression"),
    15: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.user) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.cohortMembership) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.sessionProfile) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.session) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.view) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.request) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.insertion) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.impression) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.user.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.user, fieldNumber: 7)
    }
    if !self.cohortMembership.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cohortMembership, fieldNumber: 8)
    }
    if !self.sessionProfile.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionProfile, fieldNumber: 9)
    }
    if !self.session.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.session, fieldNumber: 10)
    }
    if !self.view.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.view, fieldNumber: 11)
    }
    if !self.request.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.request, fieldNumber: 12)
    }
    if !self.insertion.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertion, fieldNumber: 13)
    }
    if !self.impression.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.impression, fieldNumber: 14)
    }
    if !self.action.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.action, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LogRequest, rhs: Event_LogRequest) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.user != rhs.user {return false}
    if lhs.cohortMembership != rhs.cohortMembership {return false}
    if lhs.sessionProfile != rhs.sessionProfile {return false}
    if lhs.session != rhs.session {return false}
    if lhs.view != rhs.view {return false}
    if lhs.request != rhs.request {return false}
    if lhs.insertion != rhs.insertion {return false}
    if lhs.impression != rhs.impression {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_FlatEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlatEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "ids"),
    7: .same(proto: "user"),
    9: .standard(proto: "session_profile"),
    10: .same(proto: "session"),
    11: .same(proto: "view"),
    12: .same(proto: "request"),
    13: .same(proto: "insertion"),
    14: .same(proto: "impression"),
    15: .same(proto: "action"),
    16: .standard(proto: "latest_impressions"),
  ]

  fileprivate class _StorageClass {
    var _ids: Event_JoinedIdentifiers? = nil
    var _user: Event_User? = nil
    var _sessionProfile: Event_SessionProfile? = nil
    var _session: Event_Session? = nil
    var _view: Event_View? = nil
    var _request: Delivery_Request? = nil
    var _insertion: Delivery_Insertion? = nil
    var _impression: Event_Impression? = nil
    var _action: Event_Action? = nil
    var _latestImpressions: Event_LatestImpressions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ids = source._ids
      _user = source._user
      _sessionProfile = source._sessionProfile
      _session = source._session
      _view = source._view
      _request = source._request
      _insertion = source._insertion
      _impression = source._impression
      _action = source._action
      _latestImpressions = source._latestImpressions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._ids) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._sessionProfile) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._view) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._insertion) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._impression) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._action) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._latestImpressions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._sessionProfile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._view {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._insertion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._impression {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._latestImpressions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_FlatEvent, rhs: Event_FlatEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ids != rhs_storage._ids {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._sessionProfile != rhs_storage._sessionProfile {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._view != rhs_storage._view {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._insertion != rhs_storage._insertion {return false}
        if _storage._impression != rhs_storage._impression {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._latestImpressions != rhs_storage._latestImpressions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
