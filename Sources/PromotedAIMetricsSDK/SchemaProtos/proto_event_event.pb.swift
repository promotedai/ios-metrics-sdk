// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/event/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The arm (experiment's group) when the Cohort is for an experiment.
/// Next ID = 6.
public enum Event_CohortArm: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownGroup // = 0
  case control // = 1
  case treatment // = 2

  /// These are generic arms (groups) that can be used when there are multiple treatments.
  case treatment1 // = 3
  case treatment2 // = 4
  case treatment3 // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownGroup
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownGroup
    case 1: self = .control
    case 2: self = .treatment
    case 3: self = .treatment1
    case 4: self = .treatment2
    case 5: self = .treatment3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownGroup: return 0
    case .control: return 1
    case .treatment: return 2
    case .treatment1: return 3
    case .treatment2: return 4
    case .treatment3: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_CohortArm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_CohortArm] = [
    .unknownGroup,
    .control,
    .treatment,
    .treatment1,
    .treatment2,
    .treatment3,
  ]
}

#endif  // swift(>=4.2)

/// Next ID = 4.
public enum Event_DeviceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownDeviceType // = 0
  case desktop // = 1
  case mobile // = 2
  case tablet // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownDeviceType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDeviceType
    case 1: self = .desktop
    case 2: self = .mobile
    case 3: self = .tablet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownDeviceType: return 0
    case .desktop: return 1
    case .mobile: return 2
    case .tablet: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_DeviceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_DeviceType] = [
    .unknownDeviceType,
    .desktop,
    .mobile,
    .tablet,
  ]
}

#endif  // swift(>=4.2)

/// Next ID = 11.
public enum Event_UseCase: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Need to handle in wrapper proto.
  case custom // = 1
  case search // = 2
  case searchSuggestions // = 3
  case feed // = 4
  case relatedContent // = 5
  case closeUp // = 6
  case categoryContent // = 7
  case myContent // = 8
  case mySavedContent // = 9
  case sellerContent // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .custom
    case 2: self = .search
    case 3: self = .searchSuggestions
    case 4: self = .feed
    case 5: self = .relatedContent
    case 6: self = .closeUp
    case 7: self = .categoryContent
    case 8: self = .myContent
    case 9: self = .mySavedContent
    case 10: self = .sellerContent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .custom: return 1
    case .search: return 2
    case .searchSuggestions: return 3
    case .feed: return 4
    case .relatedContent: return 5
    case .closeUp: return 6
    case .categoryContent: return 7
    case .myContent: return 8
    case .mySavedContent: return 9
    case .sellerContent: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Event_UseCase: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_UseCase] = [
    .unknown,
    .custom,
    .search,
    .searchSuggestions,
    .feed,
    .relatedContent,
    .closeUp,
    .categoryContent,
    .myContent,
    .mySavedContent,
    .sellerContent,
  ]
}

#endif  // swift(>=4.2)

/// This structure is used to help deduplicate identifiers that live in many
/// event types.
/// Next ID = 9.
public struct Event_JoinedIdentifiers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformID: UInt64 = 0

  public var userID: String = String()

  public var logUserID: String = String()

  public var sessionID: String = String()

  public var viewID: String = String()

  public var requestID: String = String()

  public var insertionID: String = String()

  public var impressionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Supports custom messages per platform.
/// Next ID = 3;
public struct Event_Payload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Event_Payload.OneOf_Payload? = nil

  /// Optional.  Contains protobuf serialized bytes.
  public var payloadBytes: Data {
    get {
      if case .payloadBytes(let v)? = payload {return v}
      return Data()
    }
    set {payload = .payloadBytes(newValue)}
  }

  /// Optional.  Contains struct/json {Platform}User.
  public var `struct`: SwiftProtobuf.Google_Protobuf_Struct {
    get {
      if case .struct(let v)? = payload {return v}
      return SwiftProtobuf.Google_Protobuf_Struct()
    }
    set {payload = .struct(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    /// Optional.  Contains protobuf serialized bytes.
    case payloadBytes(Data)
    /// Optional.  Contains struct/json {Platform}User.
    case `struct`(SwiftProtobuf.Google_Protobuf_Struct)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_Payload.OneOf_Payload, rhs: Event_Payload.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.payloadBytes, .payloadBytes): return {
        guard case .payloadBytes(let l) = lhs, case .payloadBytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.struct, .struct): return {
        guard case .struct(let l) = lhs, case .struct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Used to store user properties.  E.g. purchasedContentIds.
/// Clients can update each User multiple times by logging the User with the same
/// user_id.  Unset fields will not be updated. Repeated fields will act like a
/// merge if the item has a key.  Otherwise, it'll act like an append.
/// Next ID = 7.
public struct Event_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 = 0

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var userID: String = String()

  /// Optional.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String = String()

  /// Required.  Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _payload ?? Event_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Event_Payload? = nil
}

/// For linking users to cohorts.
/// Next ID = 15.
public struct Event_CohortMembership {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 = 0

  /// Optional.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String = String()

  /// Required.  Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Optional.  This can contain a log UUID to help track down log records.
  public var membershipID: String = String()

  /// Optional.  This field refers to the cohort (currently stored as an enum).
  public var cohortID: String = String()

  /// Optional.
  public var arm: Event_CohortArm = .unknownGroup

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _payload ?? Event_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Event_Payload? = nil
}

/// A sub-message containing Device info.
/// Next ID = 12.
public struct Event_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceType: Event_DeviceType = .unknownDeviceType

  /// android.os.Build.BRAND
  public var brand: String = String()

  /// android.os.Build.DEVICE
  public var deviceName: String = String()

  /// android.os.Build.DISPLAY
  public var display: String = String()

  /// android.os.Build.MODEL
  public var model: String = String()

  public var resolutionWidth: UInt32 = 0

  public var resolutionHeight: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// A newer alternative to user agent strings.
public struct Event_ClientHints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isMobile: Bool = false

  public var brand: [Event_ClientHintBrand] = []

  public var architecture: String = String()

  public var model: String = String()

  public var platform: String = String()

  public var platformVersion: String = String()

  public var uaFullVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://raw.githubusercontent.com/snowplow/iglu-central/master/schemas/org.ietf/http_client_hints/jsonschema/1-0-0
/// a part of ClientHints.
public struct Event_ClientHintBrand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var brand: String = String()

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A sub-message containing Browser info.
/// Next ID = 4.
public struct Event_Browser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAgent: String = String()

  public var viewportWidth: UInt32 = 0

  public var viewportHeight: UInt32 = 0

  public var clientHints: Event_ClientHints {
    get {return _clientHints ?? Event_ClientHints()}
    set {_clientHints = newValue}
  }
  /// Returns true if `clientHints` has been explicitly set.
  public var hasClientHints: Bool {return self._clientHints != nil}
  /// Clears the value of `clientHints`. Subsequent reads from it will return its default value.
  public mutating func clearClientHints() {self._clientHints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientHints: Event_ClientHints? = nil
}

/// Profile (contains pii) version of Session.
/// Next ID = 20.
public struct Event_SessionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 = 0

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var userID: String = String()

  /// Required.  Can be optional if set on a wrapping LogRequest.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Required. This is the primary ID.
  public var sessionID: String = String()

  /// Geo.
  /// Optional.  We'll use IP Address to guess the user's location.
  public var ipAddress: Event_SessionProfile.OneOf_IpAddress? = nil

  public var ipAddressV4: UInt32 {
    get {
      if case .ipAddressV4(let v)? = ipAddress {return v}
      return 0
    }
    set {ipAddress = .ipAddressV4(newValue)}
  }

  public var ipAddressV6: Data {
    get {
      if case .ipAddressV6(let v)? = ipAddress {return v}
      return Data()
    }
    set {ipAddress = .ipAddressV6(newValue)}
  }

  /// [-90, 90]
  public var latitude: Double = 0

  /// [-180, 180]
  public var longitude: Double = 0

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _payload ?? Event_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Geo.
  /// Optional.  We'll use IP Address to guess the user's location.
  public enum OneOf_IpAddress: Equatable {
    case ipAddressV4(UInt32)
    case ipAddressV6(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Event_SessionProfile.OneOf_IpAddress, rhs: Event_SessionProfile.OneOf_IpAddress) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ipAddressV4, .ipAddressV4): return {
        guard case .ipAddressV4(let l) = lhs, case .ipAddressV4(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ipAddressV6, .ipAddressV6): return {
        guard case .ipAddressV6(let l) = lhs, case .ipAddressV6(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _payload: Event_Payload? = nil
}

/// A period of activity by a single User.  Users can have multiple Sessions.
/// Clients can update a Session multiple times by logging multiple Sessions with
/// the same session_id.  Unset fields will not be updated.  Repeated fields will
/// act like a merge if the item has a key.  Otherwise, it'll act like an append.
/// Next ID = 22.
public struct Event_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 = 0

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String = String()

  /// Required.  Can be optional if set on a wrapping LogRequest.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Required. This is the primary ID.
  public var sessionID: String = String()

  /// Optional. Start time. If not set, we'll infer this from the API calls.
  public var startEpochMillis: UInt64 = 0

  /// Optional. End time. If not set, we'll infer this from the API calls.
  public var exclusiveEndEpochMillis: UInt64 = 0

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _payload ?? Event_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Event_Payload? = nil
}

/// A view of a single page (e.g. feed, search results, etc).
/// Next ID = 37.
public struct Event_View {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String {
    get {return _storage._logUserID}
    set {_uniqueStorage()._logUserID = newValue}
  }

  /// Required.  Can be optional if set on a wrapping LogRequest.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 {
    get {return _storage._clientLogTimestamp}
    set {_uniqueStorage()._clientLogTimestamp = newValue}
  }

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 {
    get {return _storage._eventApiTimestamp}
    set {_uniqueStorage()._eventApiTimestamp = newValue}
  }

  /// Required.  This is a UUID that is generated by the client.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional.  The name of the view.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional.  This is the url for the page.
  /// Q - how should this work with experiments?  Should we handle experiments separately?
  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  /// Optional.
  public var useCase: Event_UseCase {
    get {return _storage._useCase}
    set {_uniqueStorage()._useCase = newValue}
  }

  /// Optional.
  public var searchQuery: String {
    get {return _storage._searchQuery}
    set {_uniqueStorage()._searchQuery = newValue}
  }

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _storage._payload ?? Event_Payload()}
    set {_uniqueStorage()._payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return _storage._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {_uniqueStorage()._payload = nil}

  public var platformType: Event_View.PlatformType {
    get {return _storage._platformType}
    set {_uniqueStorage()._platformType = newValue}
  }

  /// Optional.  Can be a full referrer string.  Could be just the UTM.
  public var referrer: String {
    get {return _storage._referrer}
    set {_uniqueStorage()._referrer = newValue}
  }

  /// Optional.
  public var device: Event_Device {
    get {return _storage._device ?? Event_Device()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {_uniqueStorage()._device = nil}

  /// Optional.
  public var browser: Event_Browser {
    get {return _storage._browser ?? Event_Browser()}
    set {_uniqueStorage()._browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return _storage._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {_uniqueStorage()._browser = nil}

  public var documentWidth: UInt32 {
    get {return _storage._documentWidth}
    set {_uniqueStorage()._documentWidth = newValue}
  }

  public var documentHeight: UInt32 {
    get {return _storage._documentHeight}
    set {_uniqueStorage()._documentHeight = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Next ID = 4.
  public enum PlatformType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case web // = 1
    case mobileOrTablet // = 2
    case desktop // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .web
      case 2: self = .mobileOrTablet
      case 3: self = .desktop
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .web: return 1
      case .mobileOrTablet: return 2
      case .desktop: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Event_View.PlatformType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Event_View.PlatformType] = [
    .unknown,
    .web,
    .mobileOrTablet,
    .desktop,
  ]
}

#endif  // swift(>=4.2)

/// Request for Delivery
/// Next ID = 3.
public struct Event_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// We require the following params to be set: log_user_id, ...
  public var header: Event_RequestHeader {
    get {return _header ?? Event_RequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Supports passing (1) content IDs or (2) a list of content.
  public var insertion: [Event_Insertion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Event_RequestHeader? = nil
}

/// Represents a Request metadata in Delivery API and Metrics API.
/// The more expensive parts of the request
///
/// Next ID = 17.
public struct Event_RequestHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 = 0

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String = String()

  /// Required.  Can be optional if set on a wrapping LogRequest.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Required.  This is a UUID that is generated by the client.
  public var requestID: String = String()

  /// Required.
  public var viewID: String = String()

  /// Optional.
  public var sessionID: String = String()

  /// Optional.
  public var useCase: Event_UseCase = .unknown

  /// Optional.
  public var searchQuery: String = String()

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _payload ?? Event_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Event_Payload? = nil
}

/// This Event represents a Content being served at a certain position regardless
/// of it was views by a user. Insertions are immutable.
/// Next ID = 32.
public struct Event_Insertion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 {
    get {return _storage._platformID}
    set {_uniqueStorage()._platformID = newValue}
  }

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String {
    get {return _storage._logUserID}
    set {_uniqueStorage()._logUserID = newValue}
  }

  /// Required.  Can be optional if set on a wrapping LogRequest.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 {
    get {return _storage._clientLogTimestamp}
    set {_uniqueStorage()._clientLogTimestamp = newValue}
  }

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 {
    get {return _storage._eventApiTimestamp}
    set {_uniqueStorage()._eventApiTimestamp = newValue}
  }

  /// Required.  This is a UUID that is generated by the client.
  public var insertionID: String {
    get {return _storage._insertionID}
    set {_uniqueStorage()._insertionID = newValue}
  }

  /// Optional.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Optional.
  public var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Optional.
  public var viewID: String {
    get {return _storage._viewID}
    set {_uniqueStorage()._viewID = newValue}
  }

  /// Optional.  We'll look this up using the external_content_id.
  public var contentID: String {
    get {return _storage._contentID}
    set {_uniqueStorage()._contentID = newValue}
  }

  /// Optional.  If using Promotion's CMS.
  public var promotedaiContentID: UInt64 {
    get {return _storage._promotedaiContentID}
    set {_uniqueStorage()._promotedaiContentID = newValue}
  }

  /// Optional.  0-based.
  public var position: UInt64 {
    get {return _storage._position}
    set {_uniqueStorage()._position = newValue}
  }

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _storage._payload ?? Event_Payload()}
    set {_uniqueStorage()._payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return _storage._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {_uniqueStorage()._payload = nil}

  /// Internal.
  public var insertionLogFlatPromotion: Promotion_InsertionLogFlatPromotion {
    get {return _storage._insertionLogFlatPromotion ?? Promotion_InsertionLogFlatPromotion()}
    set {_uniqueStorage()._insertionLogFlatPromotion = newValue}
  }
  /// Returns true if `insertionLogFlatPromotion` has been explicitly set.
  public var hasInsertionLogFlatPromotion: Bool {return _storage._insertionLogFlatPromotion != nil}
  /// Clears the value of `insertionLogFlatPromotion`. Subsequent reads from it will return its default value.
  public mutating func clearInsertionLogFlatPromotion() {_uniqueStorage()._insertionLogFlatPromotion = nil}

  /// If we use AWS Personalize.
  public var awsPersonalizeRecommendationID: String {
    get {return _storage._awsPersonalizeRecommendationID}
    set {_uniqueStorage()._awsPersonalizeRecommendationID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// When an Insertion is shown to a user.
/// Impressions are immutable.
/// Next ID = 17.
public struct Event_Impression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 = 0

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String = String()

  /// Required.  Can be optional if set on a wrapping LogRequest.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Required.  This is a UUID that is generated by the client.
  public var impressionID: String = String()

  /// Optional.
  public var insertionID: String = String()

  /// Optional.
  public var requestID: String = String()

  /// Optional.
  public var sessionID: String = String()

  /// Optional.
  public var viewID: String = String()

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _payload ?? Event_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Event_Payload? = nil
}

/// Clicks are immutable.
/// Next ID = 23.
public struct Event_Click {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Read-only.  This is set by Event API.
  public var platformID: UInt64 = 0

  /// Required.  Can be optional if set on a wrapping LogRequest.
  public var logUserID: String = String()

  /// Required.  Can be optional if set on a wrapping LogRequest.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  /// Clients should not set this.  This gets set in the Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Required.  This is a UUID for the click.
  public var clickID: String = String()

  /// Optional.
  public var impressionID: String = String()

  /// Optional.
  public var insertionID: String = String()

  /// Optional.
  public var requestID: String = String()

  /// Optional.
  public var sessionID: String = String()

  /// Optional.
  public var viewID: String = String()

  /// Optional.  Custom message per platform.
  public var payload: Event_Payload {
    get {return _payload ?? Event_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  /// Optional.  Name of the click.  E.g. "FILTER_UPDATED" or  "CLOSEUP".
  /// Do not stick parameters in this name.
  public var name: String = String()

  /// Optional.  The next URL.
  public var targetURL: String = String()

  /// Optional.  The clicked element ID.
  public var elementID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Event_Payload? = nil
}

/// Contains a list of recent impressions for a flat event.
/// The list is wrapped in this message so (1) we can differentiate between null
/// and zero and (2) we can add more fields later.
/// For Promoted-internal use only.
/// Next ID = 2.
public struct Event_LatestImpressions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ordered with latest impressions at the end of the repeated list.
  public var impression: [Event_LatestImpression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A smaller Impression to be used on LatestImpressions.
/// For Promoted-internal use only.
/// Next ID = 6.
public struct Event_LatestImpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var impressionID: String = String()

  public var contentID: String = String()

  /// Optional.  Depends on if the client sets it.  This can be impacted by
  /// client clock skew.
  public var clientLogTimestamp: UInt64 = 0

  /// Required.  Generated in Event API.
  public var eventApiTimestamp: UInt64 = 0

  /// Required.  This is the event timestamp in our stream job (currently the
  /// Kafka insertion timestamp).
  public var eventTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A way to batch up log requests into the same request.
/// Clients can reference logs in different batches.
/// Next ID = 21.
public struct Event_LogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  Default derived from API Key or LogRequest.
  public var platformID: UInt64 = 0

  /// Required.
  public var userID: String = String()

  /// Required.
  public var logUserID: String = String()

  /// Optional.  Used as a default for each log record.
  /// Client timestamp when event was created.
  public var clientLogTimestamp: UInt64 = 0

  public var user: [Event_User] = []

  public var cohortMembership: [Event_CohortMembership] = []

  public var sessionProfile: [Event_SessionProfile] = []

  public var session: [Event_Session] = []

  public var view: [Event_View] = []

  public var request: [Event_Request] = []

  public var insertion: [Event_Insertion] = []

  public var impression: [Event_Impression] = []

  public var click: [Event_Click] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Internal Proto used for flattened events.
/// Keep proto IDs matching LogRequest.
/// Next ID = 21.
public struct Event_FlatEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: Event_JoinedIdentifiers {
    get {return _storage._ids ?? Event_JoinedIdentifiers()}
    set {_uniqueStorage()._ids = newValue}
  }
  /// Returns true if `ids` has been explicitly set.
  public var hasIds: Bool {return _storage._ids != nil}
  /// Clears the value of `ids`. Subsequent reads from it will return its default value.
  public mutating func clearIds() {_uniqueStorage()._ids = nil}

  public var user: Event_User {
    get {return _storage._user ?? Event_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var sessionProfile: Event_SessionProfile {
    get {return _storage._sessionProfile ?? Event_SessionProfile()}
    set {_uniqueStorage()._sessionProfile = newValue}
  }
  /// Returns true if `sessionProfile` has been explicitly set.
  public var hasSessionProfile: Bool {return _storage._sessionProfile != nil}
  /// Clears the value of `sessionProfile`. Subsequent reads from it will return its default value.
  public mutating func clearSessionProfile() {_uniqueStorage()._sessionProfile = nil}

  public var session: Event_Session {
    get {return _storage._session ?? Event_Session()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {_uniqueStorage()._session = nil}

  public var view: Event_View {
    get {return _storage._view ?? Event_View()}
    set {_uniqueStorage()._view = newValue}
  }
  /// Returns true if `view` has been explicitly set.
  public var hasView: Bool {return _storage._view != nil}
  /// Clears the value of `view`. Subsequent reads from it will return its default value.
  public mutating func clearView() {_uniqueStorage()._view = nil}

  public var requestHeader: Event_RequestHeader {
    get {return _storage._requestHeader ?? Event_RequestHeader()}
    set {_uniqueStorage()._requestHeader = newValue}
  }
  /// Returns true if `requestHeader` has been explicitly set.
  public var hasRequestHeader: Bool {return _storage._requestHeader != nil}
  /// Clears the value of `requestHeader`. Subsequent reads from it will return its default value.
  public mutating func clearRequestHeader() {_uniqueStorage()._requestHeader = nil}

  public var insertion: Event_Insertion {
    get {return _storage._insertion ?? Event_Insertion()}
    set {_uniqueStorage()._insertion = newValue}
  }
  /// Returns true if `insertion` has been explicitly set.
  public var hasInsertion: Bool {return _storage._insertion != nil}
  /// Clears the value of `insertion`. Subsequent reads from it will return its default value.
  public mutating func clearInsertion() {_uniqueStorage()._insertion = nil}

  public var impression: Event_Impression {
    get {return _storage._impression ?? Event_Impression()}
    set {_uniqueStorage()._impression = newValue}
  }
  /// Returns true if `impression` has been explicitly set.
  public var hasImpression: Bool {return _storage._impression != nil}
  /// Clears the value of `impression`. Subsequent reads from it will return its default value.
  public mutating func clearImpression() {_uniqueStorage()._impression = nil}

  public var click: Event_Click {
    get {return _storage._click ?? Event_Click()}
    set {_uniqueStorage()._click = newValue}
  }
  /// Returns true if `click` has been explicitly set.
  public var hasClick: Bool {return _storage._click != nil}
  /// Clears the value of `click`. Subsequent reads from it will return its default value.
  public mutating func clearClick() {_uniqueStorage()._click = nil}

  /// For Promoted-internal use only.
  public var latestImpressions: Event_LatestImpressions {
    get {return _storage._latestImpressions ?? Event_LatestImpressions()}
    set {_uniqueStorage()._latestImpressions = newValue}
  }
  /// Returns true if `latestImpressions` has been explicitly set.
  public var hasLatestImpressions: Bool {return _storage._latestImpressions != nil}
  /// Clears the value of `latestImpressions`. Subsequent reads from it will return its default value.
  public mutating func clearLatestImpressions() {_uniqueStorage()._latestImpressions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "event"

extension Event_CohortArm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_GROUP"),
    1: .same(proto: "CONTROL"),
    2: .same(proto: "TREATMENT"),
    3: .same(proto: "TREATMENT1"),
    4: .same(proto: "TREATMENT2"),
    5: .same(proto: "TREATMENT3"),
  ]
}

extension Event_DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DEVICE_TYPE"),
    1: .same(proto: "DESKTOP"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "TABLET"),
  ]
}

extension Event_UseCase: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CUSTOM"),
    2: .same(proto: "SEARCH"),
    3: .same(proto: "SEARCH_SUGGESTIONS"),
    4: .same(proto: "FEED"),
    5: .same(proto: "RELATED_CONTENT"),
    6: .same(proto: "CLOSE_UP"),
    7: .same(proto: "CATEGORY_CONTENT"),
    8: .same(proto: "MY_CONTENT"),
    9: .same(proto: "MY_SAVED_CONTENT"),
    10: .same(proto: "SELLER_CONTENT"),
  ]
}

extension Event_JoinedIdentifiers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinedIdentifiers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "session_id"),
    5: .standard(proto: "view_id"),
    6: .standard(proto: "request_id"),
    7: .standard(proto: "insertion_id"),
    8: .standard(proto: "impression_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 7)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_JoinedIdentifiers, rhs: Event_JoinedIdentifiers) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payload_bytes"),
    2: .same(proto: "struct"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.payload != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.payload = .payloadBytes(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .struct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .struct(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .payloadBytes?: try {
      guard case .payloadBytes(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .struct?: try {
      guard case .struct(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Payload, rhs: Event_Payload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    6: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 5)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_User, rhs: Event_User) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_CohortMembership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CohortMembership"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    10: .standard(proto: "membership_id"),
    12: .standard(proto: "cohort_id"),
    13: .same(proto: "arm"),
    14: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.membershipID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.cohortID) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.arm) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 5)
    }
    if !self.membershipID.isEmpty {
      try visitor.visitSingularStringField(value: self.membershipID, fieldNumber: 10)
    }
    if !self.cohortID.isEmpty {
      try visitor.visitSingularStringField(value: self.cohortID, fieldNumber: 12)
    }
    if self.arm != .unknownGroup {
      try visitor.visitSingularEnumField(value: self.arm, fieldNumber: 13)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_CohortMembership, rhs: Event_CohortMembership) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.membershipID != rhs.membershipID {return false}
    if lhs.cohortID != rhs.cohortID {return false}
    if lhs.arm != rhs.arm {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_type"),
    3: .same(proto: "brand"),
    5: .standard(proto: "device_name"),
    7: .same(proto: "display"),
    9: .same(proto: "model"),
    10: .standard(proto: "resolution_width"),
    11: .standard(proto: "resolution_height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.resolutionWidth) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.resolutionHeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceType != .unknownDeviceType {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 1)
    }
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 3)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 5)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 7)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 9)
    }
    if self.resolutionWidth != 0 {
      try visitor.visitSingularUInt32Field(value: self.resolutionWidth, fieldNumber: 10)
    }
    if self.resolutionHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.resolutionHeight, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Device, rhs: Event_Device) -> Bool {
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.display != rhs.display {return false}
    if lhs.model != rhs.model {return false}
    if lhs.resolutionWidth != rhs.resolutionWidth {return false}
    if lhs.resolutionHeight != rhs.resolutionHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ClientHints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_mobile"),
    2: .same(proto: "brand"),
    3: .same(proto: "architecture"),
    4: .same(proto: "model"),
    5: .same(proto: "platform"),
    6: .standard(proto: "platform_version"),
    7: .standard(proto: "ua_full_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isMobile) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.brand) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.platformVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.uaFullVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMobile != false {
      try visitor.visitSingularBoolField(value: self.isMobile, fieldNumber: 1)
    }
    if !self.brand.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.brand, fieldNumber: 2)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 3)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 4)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 5)
    }
    if !self.platformVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.platformVersion, fieldNumber: 6)
    }
    if !self.uaFullVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.uaFullVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ClientHints, rhs: Event_ClientHints) -> Bool {
    if lhs.isMobile != rhs.isMobile {return false}
    if lhs.brand != rhs.brand {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.model != rhs.model {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.platformVersion != rhs.platformVersion {return false}
    if lhs.uaFullVersion != rhs.uaFullVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_ClientHintBrand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientHintBrand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brand"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.brand) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.brand.isEmpty {
      try visitor.visitSingularStringField(value: self.brand, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_ClientHintBrand, rhs: Event_ClientHintBrand) -> Bool {
    if lhs.brand != rhs.brand {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Browser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Browser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_agent"),
    2: .standard(proto: "viewport_width"),
    3: .standard(proto: "viewport_height"),
    4: .standard(proto: "client_hints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.viewportWidth) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.viewportHeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientHints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 1)
    }
    if self.viewportWidth != 0 {
      try visitor.visitSingularUInt32Field(value: self.viewportWidth, fieldNumber: 2)
    }
    if self.viewportHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.viewportHeight, fieldNumber: 3)
    }
    if let v = self._clientHints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Browser, rhs: Event_Browser) -> Bool {
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.viewportWidth != rhs.viewportWidth {return false}
    if lhs.viewportHeight != rhs.viewportHeight {return false}
    if lhs._clientHints != rhs._clientHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_SessionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    11: .standard(proto: "session_id"),
    15: .standard(proto: "ip_address_v4"),
    16: .standard(proto: "ip_address_v6"),
    17: .same(proto: "latitude"),
    18: .same(proto: "longitude"),
    19: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 15: try {
        if self.ipAddress != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularFixed32Field(value: &v)
        if let v = v {self.ipAddress = .ipAddressV4(v)}
      }()
      case 16: try {
        if self.ipAddress != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.ipAddress = .ipAddressV6(v)}
      }()
      case 17: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 18: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 19: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 5)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 11)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.ipAddress {
    case .ipAddressV4?: try {
      guard case .ipAddressV4(let v)? = self.ipAddress else { preconditionFailure() }
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 15)
    }()
    case .ipAddressV6?: try {
      guard case .ipAddressV6(let v)? = self.ipAddress else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 17)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 18)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_SessionProfile, rhs: Event_SessionProfile) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Session"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    11: .standard(proto: "session_id"),
    13: .standard(proto: "start_epoch_millis"),
    14: .standard(proto: "exclusive_end_epoch_millis"),
    19: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.startEpochMillis) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self.exclusiveEndEpochMillis) }()
      case 19: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 5)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 11)
    }
    if self.startEpochMillis != 0 {
      try visitor.visitSingularUInt64Field(value: self.startEpochMillis, fieldNumber: 13)
    }
    if self.exclusiveEndEpochMillis != 0 {
      try visitor.visitSingularUInt64Field(value: self.exclusiveEndEpochMillis, fieldNumber: 14)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Session, rhs: Event_Session) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.startEpochMillis != rhs.startEpochMillis {return false}
    if lhs.exclusiveEndEpochMillis != rhs.exclusiveEndEpochMillis {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".View"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    11: .standard(proto: "view_id"),
    12: .standard(proto: "session_id"),
    13: .same(proto: "name"),
    14: .same(proto: "url"),
    15: .standard(proto: "use_case"),
    16: .standard(proto: "search_query"),
    17: .same(proto: "payload"),
    30: .standard(proto: "platform_type"),
    32: .same(proto: "referrer"),
    33: .same(proto: "device"),
    34: .same(proto: "browser"),
    35: .standard(proto: "document_width"),
    36: .standard(proto: "document_height"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _logUserID: String = String()
    var _clientLogTimestamp: UInt64 = 0
    var _eventApiTimestamp: UInt64 = 0
    var _viewID: String = String()
    var _sessionID: String = String()
    var _name: String = String()
    var _url: String = String()
    var _useCase: Event_UseCase = .unknown
    var _searchQuery: String = String()
    var _payload: Event_Payload? = nil
    var _platformType: Event_View.PlatformType = .unknown
    var _referrer: String = String()
    var _device: Event_Device? = nil
    var _browser: Event_Browser? = nil
    var _documentWidth: UInt32 = 0
    var _documentHeight: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _logUserID = source._logUserID
      _clientLogTimestamp = source._clientLogTimestamp
      _eventApiTimestamp = source._eventApiTimestamp
      _viewID = source._viewID
      _sessionID = source._sessionID
      _name = source._name
      _url = source._url
      _useCase = source._useCase
      _searchQuery = source._searchQuery
      _payload = source._payload
      _platformType = source._platformType
      _referrer = source._referrer
      _device = source._device
      _browser = source._browser
      _documentWidth = source._documentWidth
      _documentHeight = source._documentHeight
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._logUserID) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._clientLogTimestamp) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._eventApiTimestamp) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._useCase) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._searchQuery) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._payload) }()
        case 30: try { try decoder.decodeSingularEnumField(value: &_storage._platformType) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._referrer) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._browser) }()
        case 35: try { try decoder.decodeSingularUInt32Field(value: &_storage._documentWidth) }()
        case 36: try { try decoder.decodeSingularUInt32Field(value: &_storage._documentHeight) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if !_storage._logUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logUserID, fieldNumber: 3)
      }
      if _storage._clientLogTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._clientLogTimestamp, fieldNumber: 4)
      }
      if _storage._eventApiTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._eventApiTimestamp, fieldNumber: 5)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 11)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 12)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 13)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 14)
      }
      if _storage._useCase != .unknown {
        try visitor.visitSingularEnumField(value: _storage._useCase, fieldNumber: 15)
      }
      if !_storage._searchQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._searchQuery, fieldNumber: 16)
      }
      if let v = _storage._payload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if _storage._platformType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._platformType, fieldNumber: 30)
      }
      if !_storage._referrer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._referrer, fieldNumber: 32)
      }
      if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if let v = _storage._browser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
      if _storage._documentWidth != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._documentWidth, fieldNumber: 35)
      }
      if _storage._documentHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._documentHeight, fieldNumber: 36)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_View, rhs: Event_View) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._logUserID != rhs_storage._logUserID {return false}
        if _storage._clientLogTimestamp != rhs_storage._clientLogTimestamp {return false}
        if _storage._eventApiTimestamp != rhs_storage._eventApiTimestamp {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._useCase != rhs_storage._useCase {return false}
        if _storage._searchQuery != rhs_storage._searchQuery {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._platformType != rhs_storage._platformType {return false}
        if _storage._referrer != rhs_storage._referrer {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._browser != rhs_storage._browser {return false}
        if _storage._documentWidth != rhs_storage._documentWidth {return false}
        if _storage._documentHeight != rhs_storage._documentHeight {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_View.PlatformType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "WEB"),
    2: .same(proto: "MOBILE_OR_TABLET"),
    3: .same(proto: "DESKTOP"),
  ]
}

extension Event_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "insertion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.insertion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.insertion.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Request, rhs: Event_Request) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.insertion != rhs.insertion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_RequestHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    11: .standard(proto: "request_id"),
    12: .standard(proto: "view_id"),
    15: .standard(proto: "session_id"),
    13: .standard(proto: "use_case"),
    14: .standard(proto: "search_query"),
    16: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.useCase) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.searchQuery) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 11)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 12)
    }
    if self.useCase != .unknown {
      try visitor.visitSingularEnumField(value: self.useCase, fieldNumber: 13)
    }
    if !self.searchQuery.isEmpty {
      try visitor.visitSingularStringField(value: self.searchQuery, fieldNumber: 14)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 15)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_RequestHeader, rhs: Event_RequestHeader) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.useCase != rhs.useCase {return false}
    if lhs.searchQuery != rhs.searchQuery {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Insertion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Insertion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    11: .standard(proto: "insertion_id"),
    12: .standard(proto: "request_id"),
    16: .standard(proto: "session_id"),
    17: .standard(proto: "view_id"),
    13: .standard(proto: "content_id"),
    14: .standard(proto: "promotedai_content_id"),
    15: .same(proto: "position"),
    18: .same(proto: "payload"),
    30: .standard(proto: "insertion_log_flat_promotion"),
    31: .standard(proto: "aws_personalize_recommendation_id"),
  ]

  fileprivate class _StorageClass {
    var _platformID: UInt64 = 0
    var _logUserID: String = String()
    var _clientLogTimestamp: UInt64 = 0
    var _eventApiTimestamp: UInt64 = 0
    var _insertionID: String = String()
    var _requestID: String = String()
    var _sessionID: String = String()
    var _viewID: String = String()
    var _contentID: String = String()
    var _promotedaiContentID: UInt64 = 0
    var _position: UInt64 = 0
    var _payload: Event_Payload? = nil
    var _insertionLogFlatPromotion: Promotion_InsertionLogFlatPromotion? = nil
    var _awsPersonalizeRecommendationID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platformID = source._platformID
      _logUserID = source._logUserID
      _clientLogTimestamp = source._clientLogTimestamp
      _eventApiTimestamp = source._eventApiTimestamp
      _insertionID = source._insertionID
      _requestID = source._requestID
      _sessionID = source._sessionID
      _viewID = source._viewID
      _contentID = source._contentID
      _promotedaiContentID = source._promotedaiContentID
      _position = source._position
      _payload = source._payload
      _insertionLogFlatPromotion = source._insertionLogFlatPromotion
      _awsPersonalizeRecommendationID = source._awsPersonalizeRecommendationID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._platformID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._logUserID) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._clientLogTimestamp) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._eventApiTimestamp) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._insertionID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._contentID) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._promotedaiContentID) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._position) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._viewID) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._payload) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._insertionLogFlatPromotion) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._awsPersonalizeRecommendationID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._platformID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._platformID, fieldNumber: 1)
      }
      if !_storage._logUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logUserID, fieldNumber: 3)
      }
      if _storage._clientLogTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._clientLogTimestamp, fieldNumber: 4)
      }
      if _storage._eventApiTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._eventApiTimestamp, fieldNumber: 5)
      }
      if !_storage._insertionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._insertionID, fieldNumber: 11)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 12)
      }
      if !_storage._contentID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentID, fieldNumber: 13)
      }
      if _storage._promotedaiContentID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._promotedaiContentID, fieldNumber: 14)
      }
      if _storage._position != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._position, fieldNumber: 15)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 16)
      }
      if !_storage._viewID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewID, fieldNumber: 17)
      }
      if let v = _storage._payload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._insertionLogFlatPromotion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if !_storage._awsPersonalizeRecommendationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._awsPersonalizeRecommendationID, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Insertion, rhs: Event_Insertion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platformID != rhs_storage._platformID {return false}
        if _storage._logUserID != rhs_storage._logUserID {return false}
        if _storage._clientLogTimestamp != rhs_storage._clientLogTimestamp {return false}
        if _storage._eventApiTimestamp != rhs_storage._eventApiTimestamp {return false}
        if _storage._insertionID != rhs_storage._insertionID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._viewID != rhs_storage._viewID {return false}
        if _storage._contentID != rhs_storage._contentID {return false}
        if _storage._promotedaiContentID != rhs_storage._promotedaiContentID {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._insertionLogFlatPromotion != rhs_storage._insertionLogFlatPromotion {return false}
        if _storage._awsPersonalizeRecommendationID != rhs_storage._awsPersonalizeRecommendationID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Impression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Impression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    11: .standard(proto: "impression_id"),
    12: .standard(proto: "insertion_id"),
    13: .standard(proto: "request_id"),
    14: .standard(proto: "session_id"),
    15: .standard(proto: "view_id"),
    16: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 5)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 11)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 12)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 13)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 14)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 15)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Impression, rhs: Event_Impression) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_Click: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Click"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    5: .standard(proto: "event_api_timestamp"),
    10: .standard(proto: "click_id"),
    11: .standard(proto: "impression_id"),
    12: .standard(proto: "insertion_id"),
    13: .standard(proto: "request_id"),
    14: .standard(proto: "session_id"),
    15: .standard(proto: "view_id"),
    16: .same(proto: "payload"),
    20: .same(proto: "name"),
    21: .standard(proto: "target_url"),
    22: .standard(proto: "element_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.clickID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.insertionID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 20: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 21: try { try decoder.decodeSingularStringField(value: &self.targetURL) }()
      case 22: try { try decoder.decodeSingularStringField(value: &self.elementID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 5)
    }
    if !self.clickID.isEmpty {
      try visitor.visitSingularStringField(value: self.clickID, fieldNumber: 10)
    }
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 11)
    }
    if !self.insertionID.isEmpty {
      try visitor.visitSingularStringField(value: self.insertionID, fieldNumber: 12)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 13)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 14)
    }
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 15)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 20)
    }
    if !self.targetURL.isEmpty {
      try visitor.visitSingularStringField(value: self.targetURL, fieldNumber: 21)
    }
    if !self.elementID.isEmpty {
      try visitor.visitSingularStringField(value: self.elementID, fieldNumber: 22)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_Click, rhs: Event_Click) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.clickID != rhs.clickID {return false}
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.insertionID != rhs.insertionID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.viewID != rhs.viewID {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.name != rhs.name {return false}
    if lhs.targetURL != rhs.targetURL {return false}
    if lhs.elementID != rhs.elementID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LatestImpressions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestImpressions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "impression"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.impression) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.impression.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.impression, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LatestImpressions, rhs: Event_LatestImpressions) -> Bool {
    if lhs.impression != rhs.impression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LatestImpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestImpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "impression_id"),
    2: .standard(proto: "content_id"),
    3: .standard(proto: "client_log_timestamp"),
    4: .standard(proto: "event_api_timestamp"),
    5: .standard(proto: "event_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.impressionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.eventApiTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.eventTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.impressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.impressionID, fieldNumber: 1)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 2)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 3)
    }
    if self.eventApiTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventApiTimestamp, fieldNumber: 4)
    }
    if self.eventTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventTimestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LatestImpression, rhs: Event_LatestImpression) -> Bool {
    if lhs.impressionID != rhs.impressionID {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.eventApiTimestamp != rhs.eventApiTimestamp {return false}
    if lhs.eventTimestamp != rhs.eventTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_LogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "platform_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "log_user_id"),
    4: .standard(proto: "client_log_timestamp"),
    10: .same(proto: "user"),
    20: .standard(proto: "cohort_membership"),
    12: .standard(proto: "session_profile"),
    13: .same(proto: "session"),
    14: .same(proto: "view"),
    15: .same(proto: "request"),
    16: .same(proto: "insertion"),
    17: .same(proto: "impression"),
    18: .same(proto: "click"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.platformID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logUserID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.clientLogTimestamp) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.user) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.sessionProfile) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.session) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.view) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.request) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.insertion) }()
      case 17: try { try decoder.decodeRepeatedMessageField(value: &self.impression) }()
      case 18: try { try decoder.decodeRepeatedMessageField(value: &self.click) }()
      case 20: try { try decoder.decodeRepeatedMessageField(value: &self.cohortMembership) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platformID != 0 {
      try visitor.visitSingularUInt64Field(value: self.platformID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.logUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.logUserID, fieldNumber: 3)
    }
    if self.clientLogTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientLogTimestamp, fieldNumber: 4)
    }
    if !self.user.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.user, fieldNumber: 10)
    }
    if !self.sessionProfile.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionProfile, fieldNumber: 12)
    }
    if !self.session.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.session, fieldNumber: 13)
    }
    if !self.view.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.view, fieldNumber: 14)
    }
    if !self.request.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.request, fieldNumber: 15)
    }
    if !self.insertion.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertion, fieldNumber: 16)
    }
    if !self.impression.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.impression, fieldNumber: 17)
    }
    if !self.click.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.click, fieldNumber: 18)
    }
    if !self.cohortMembership.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cohortMembership, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_LogRequest, rhs: Event_LogRequest) -> Bool {
    if lhs.platformID != rhs.platformID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.logUserID != rhs.logUserID {return false}
    if lhs.clientLogTimestamp != rhs.clientLogTimestamp {return false}
    if lhs.user != rhs.user {return false}
    if lhs.cohortMembership != rhs.cohortMembership {return false}
    if lhs.sessionProfile != rhs.sessionProfile {return false}
    if lhs.session != rhs.session {return false}
    if lhs.view != rhs.view {return false}
    if lhs.request != rhs.request {return false}
    if lhs.insertion != rhs.insertion {return false}
    if lhs.impression != rhs.impression {return false}
    if lhs.click != rhs.click {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Event_FlatEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlatEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "ids"),
    10: .same(proto: "user"),
    12: .standard(proto: "session_profile"),
    13: .same(proto: "session"),
    14: .same(proto: "view"),
    15: .standard(proto: "request_header"),
    16: .same(proto: "insertion"),
    17: .same(proto: "impression"),
    18: .same(proto: "click"),
    19: .standard(proto: "latest_impressions"),
  ]

  fileprivate class _StorageClass {
    var _ids: Event_JoinedIdentifiers? = nil
    var _user: Event_User? = nil
    var _sessionProfile: Event_SessionProfile? = nil
    var _session: Event_Session? = nil
    var _view: Event_View? = nil
    var _requestHeader: Event_RequestHeader? = nil
    var _insertion: Event_Insertion? = nil
    var _impression: Event_Impression? = nil
    var _click: Event_Click? = nil
    var _latestImpressions: Event_LatestImpressions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ids = source._ids
      _user = source._user
      _sessionProfile = source._sessionProfile
      _session = source._session
      _view = source._view
      _requestHeader = source._requestHeader
      _insertion = source._insertion
      _impression = source._impression
      _click = source._click
      _latestImpressions = source._latestImpressions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._ids) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._sessionProfile) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._view) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._requestHeader) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._insertion) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._impression) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._click) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._latestImpressions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._sessionProfile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._view {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._requestHeader {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._insertion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._impression {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._click {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._latestImpressions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Event_FlatEvent, rhs: Event_FlatEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ids != rhs_storage._ids {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._sessionProfile != rhs_storage._sessionProfile {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._view != rhs_storage._view {return false}
        if _storage._requestHeader != rhs_storage._requestHeader {return false}
        if _storage._insertion != rhs_storage._insertion {return false}
        if _storage._impression != rhs_storage._impression {return false}
        if _storage._click != rhs_storage._click {return false}
        if _storage._latestImpressions != rhs_storage._latestImpressions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
